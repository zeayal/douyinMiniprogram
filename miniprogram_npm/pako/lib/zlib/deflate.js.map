{"version":3,"file":"node_modules/pako/lib/zlib/deflate.js","names":["_tr_init","_tr_stored_block","_tr_flush_block","_tr_tally","_tr_align","require","adler32","crc32","msg","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_OK","Z_STREAM_END","Z_STREAM_ERROR","Z_DATA_ERROR","Z_BUF_ERROR","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","Z_UNKNOWN","Z_DEFLATED","MAX_MEM_LEVEL","MAX_WBITS","DEF_MEM_LEVEL","LENGTH_CODES","LITERALS","L_CODES","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","MIN_MATCH","MAX_MATCH","MIN_LOOKAHEAD","PRESET_DICT","INIT_STATE","GZIP_STATE","EXTRA_STATE","NAME_STATE","COMMENT_STATE","HCRC_STATE","BUSY_STATE","FINISH_STATE","BS_NEED_MORE","BS_BLOCK_DONE","BS_FINISH_STARTED","BS_FINISH_DONE","OS_CODE","err","strm","errorCode","rank","f","zero","buf","len","length","slide_hash","s","n","m","p","wsize","w_size","hash_size","head","prev","HASH_ZLIB","data","hash_shift","hash_mask","HASH","flush_pending","state","pending","avail_out","output","set","pending_buf","subarray","pending_out","next_out","total_out","flush_block_only","last","block_start","strstart","put_byte","b","putShortMSB","read_buf","start","size","avail_in","input","next_in","wrap","adler","total_in","longest_match","cur_match","match","chain_length","max_chain_length","scan","best_len","prev_length","nice_match","limit","_win","window","wmask","w_mask","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","_w_size","more","str","window_size","insert","ins_h","deflate_stored","flush","left","have","min_block","pending_buf_size","used","bi_valid","matches","high_water","deflate_fast","hash_head","bflush","match_length","max_lazy_match","sym_next","deflate_slow","max_insert","prev_match","strategy","match_available","deflate_rle","deflate_huff","Config","good_length","max_lazy","nice_length","max_chain","func","this","configuration_table","lm_init","level","DeflateState","status","gzhead","gzindex","method","last_flush","w_bits","hash_bits","dyn_ltree","Uint16Array","dyn_dtree","bl_tree","l_desc","d_desc","bl_desc","bl_count","heap","heap_len","heap_max","depth","sym_buf","lit_bufsize","sym_end","opt_len","static_len","bi_buf","deflateStateCheck","deflateResetKeep","data_type","deflateReset","ret","deflateSetHeader","deflateInit2","windowBits","memLevel","Uint8Array","deflateInit","deflate","old_flush","header","level_flags","text","hcrc","extra","name","comment","time","os","beg","copy","gzhead_extra","val","charCodeAt","bstate","deflateEnd","deflateSetDictionary","dictionary","dictLength","tmpDict","avail","next","module","exports","deflateInfo"],"sources":["node_modules/pako/lib/zlib/deflate.js"],"sourcesContent":["'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require('./trees');\nconst adler32 = require('./adler32');\nconst crc32   = require('./crc32');\nconst msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH, Z_BLOCK,\n  Z_OK, Z_STREAM_END, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR,\n  Z_DEFAULT_COMPRESSION,\n  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY,\n  Z_UNKNOWN,\n  Z_DEFLATED\n} = require('./constants');\n\n/*============================================================================*/\n\n\nconst MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nconst MAX_WBITS = 15;\n/* 32K LZ77 window */\nconst DEF_MEM_LEVEL = 8;\n\n\nconst LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nconst LITERALS      = 256;\n/* number of literal bytes 0..255 */\nconst L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nconst D_CODES       = 30;\n/* number of distance codes */\nconst BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nconst HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nconst MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst MIN_MATCH = 3;\nconst MAX_MATCH = 258;\nconst MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nconst PRESET_DICT = 0x20;\n\nconst INIT_STATE    =  42;    /* zlib header -> BUSY_STATE */\n//#ifdef GZIP\nconst GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */\n//#endif\nconst EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */\nconst NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */\nconst COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */\nconst HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */\nconst BUSY_STATE    = 113;    /* deflate -> FINISH_STATE */\nconst FINISH_STATE  = 666;    /* stream complete */\n\nconst BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nconst BS_BLOCK_DONE     = 2; /* block flush performed */\nconst BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nconst BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nconst OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nconst err = (strm, errorCode) => {\n  strm.msg = msg[errorCode];\n  return errorCode;\n};\n\nconst rank = (f) => {\n  return ((f) * 2) - ((f) > 4 ? 9 : 0);\n};\n\nconst zero = (buf) => {\n  let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n};\n\n/* ===========================================================================\n * Slide the hash table when sliding the window down (could be avoided with 32\n * bit values at the expense of memory usage). We slide even when level == 0 to\n * keep the hash table consistent if we switch back to level > 0 later.\n */\nconst slide_hash = (s) => {\n  let n, m;\n  let p;\n  let wsize = s.w_size;\n\n  n = s.hash_size;\n  p = n;\n  do {\n    m = s.head[--p];\n    s.head[p] = (m >= wsize ? m - wsize : 0);\n  } while (--n);\n  n = wsize;\n//#ifndef FASTEST\n  p = n;\n  do {\n    m = s.prev[--p];\n    s.prev[p] = (m >= wsize ? m - wsize : 0);\n    /* If n is not on any hash chain, prev[n] is garbage but\n     * its value will never be used.\n     */\n  } while (--n);\n//#endif\n};\n\n/* eslint-disable new-cap */\nlet HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n// This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n// But breaks binary compatibility\n//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\nlet HASH = HASH_ZLIB;\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output, except for\n * some deflate_stored() output, goes through this function so some\n * applications may wish to modify it to avoid allocating a large\n * strm->next_out buffer and copying into it. (See also read_buf()).\n */\nconst flush_pending = (strm) => {\n  const s = strm.state;\n\n  //_tr_flush_bits(s);\n  let len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n  strm.next_out  += len;\n  s.pending_out  += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending      -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n};\n\n\nconst flush_block_only = (s, last) => {\n  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n};\n\n\nconst put_byte = (s, b) => {\n  s.pending_buf[s.pending++] = b;\n};\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nconst putShortMSB = (s, b) => {\n\n  //  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n};\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nconst read_buf = (strm, buf, start, size) => {\n\n  let len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n};\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nconst longest_match = (s, cur_match) => {\n\n  let chain_length = s.max_chain_length;      /* max hash chain length */\n  let scan = s.strstart; /* current string */\n  let match;                       /* matched string */\n  let len;                           /* length of current match */\n  let best_len = s.prev_length;              /* best match length so far */\n  let nice_match = s.nice_match;             /* stop if match long enough */\n  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  const _win = s.window; // shortcut\n\n  const wmask = s.w_mask;\n  const prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  const strend = s.strstart + MAX_MATCH;\n  let scan_end1  = _win[scan + best_len - 1];\n  let scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n};\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nconst fill_window = (s) => {\n\n  const _w_size = s.w_size;\n  let n, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n      if (s.insert > s.strstart) {\n        s.insert = s.strstart;\n      }\n      slide_hash(s);\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    const curr = s.strstart + s.lookahead;\n//    let init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n};\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n *\n * In case deflateParams() is used to later switch to a non-zero compression\n * level, s->matches (otherwise unused when storing) keeps track of the number\n * of hash table slides to perform. If s->matches is 1, then one hash table\n * slide will be done when switching. If s->matches is 2, the maximum value\n * allowed here, then the hash table will be cleared, since two or more slides\n * is the same as a clear.\n *\n * deflate_stored() is written to minimize the number of times an input byte is\n * copied. It is most efficient with large input and output buffers, which\n * maximizes the opportunites to have a single copy from next_in to next_out.\n */\nconst deflate_stored = (s, flush) => {\n\n  /* Smallest worthy block size when not flushing or finishing. By default\n   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For\n   * large input and output buffers, the stored block size will be larger.\n   */\n  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;\n\n  /* Copy as many min_block or larger stored blocks directly to next_out as\n   * possible. If flushing, copy the remaining available input to next_out as\n   * stored blocks, if there is enough space.\n   */\n  let len, left, have, last = 0;\n  let used = s.strm.avail_in;\n  do {\n    /* Set len to the maximum size block that we can copy directly with the\n     * available input data and output space. Set left to how much of that\n     * would be copied from what's left in the window.\n     */\n    len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */\n    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n    if (s.strm.avail_out < have) {         /* need room for header */\n      break;\n    }\n      /* maximum stored block length that will fit in avail_out: */\n    have = s.strm.avail_out - have;\n    left = s.strstart - s.block_start;  /* bytes left in window */\n    if (len > left + s.strm.avail_in) {\n      len = left + s.strm.avail_in;   /* limit len to the input */\n    }\n    if (len > have) {\n      len = have;             /* limit len to the output */\n    }\n\n    /* If the stored block would be less than min_block in length, or if\n     * unable to copy all of the available input when flushing, then try\n     * copying to the window and the pending buffer instead. Also don't\n     * write an empty block when flushing -- deflate() does that.\n     */\n    if (len < min_block && ((len === 0 && flush !== Z_FINISH) ||\n                        flush === Z_NO_FLUSH ||\n                        len !== left + s.strm.avail_in)) {\n      break;\n    }\n\n    /* Make a dummy stored block in pending to get the header bytes,\n     * including any pending bits. This also updates the debugging counts.\n     */\n    last = flush === Z_FINISH && len === left + s.strm.avail_in ? 1 : 0;\n    _tr_stored_block(s, 0, 0, last);\n\n    /* Replace the lengths in the dummy stored block with len. */\n    s.pending_buf[s.pending - 4] = len;\n    s.pending_buf[s.pending - 3] = len >> 8;\n    s.pending_buf[s.pending - 2] = ~len;\n    s.pending_buf[s.pending - 1] = ~len >> 8;\n\n    /* Write the stored block header bytes. */\n    flush_pending(s.strm);\n\n//#ifdef ZLIB_DEBUG\n//    /* Update debugging counts for the data about to be copied. */\n//    s->compressed_len += len << 3;\n//    s->bits_sent += len << 3;\n//#endif\n\n    /* Copy uncompressed bytes from the window to next_out. */\n    if (left) {\n      if (left > len) {\n        left = len;\n      }\n      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);\n      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);\n      s.strm.next_out += left;\n      s.strm.avail_out -= left;\n      s.strm.total_out += left;\n      s.block_start += left;\n      len -= left;\n    }\n\n    /* Copy uncompressed bytes directly from next_in to next_out, updating\n     * the check value.\n     */\n    if (len) {\n      read_buf(s.strm, s.strm.output, s.strm.next_out, len);\n      s.strm.next_out += len;\n      s.strm.avail_out -= len;\n      s.strm.total_out += len;\n    }\n  } while (last === 0);\n\n  /* Update the sliding window with the last s->w_size bytes of the copied\n   * data, or append all of the copied data to the existing window if less\n   * than s->w_size bytes were copied. Also update the number of bytes to\n   * insert in the hash tables, in the event that deflateParams() switches to\n   * a non-zero compression level.\n   */\n  used -= s.strm.avail_in;    /* number of input bytes directly copied */\n  if (used) {\n    /* If any input was used, then no unused input remains in the window,\n     * therefore s->block_start == s->strstart.\n     */\n    if (used >= s.w_size) {  /* supplant the previous history */\n      s.matches = 2;     /* clear hash */\n      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);\n      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);\n      s.strstart = s.w_size;\n      s.insert = s.strstart;\n    }\n    else {\n      if (s.window_size - s.strstart <= used) {\n        /* Slide the window down. */\n        s.strstart -= s.w_size;\n        //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n        if (s.matches < 2) {\n          s.matches++;   /* add a pending slide_hash() */\n        }\n        if (s.insert > s.strstart) {\n          s.insert = s.strstart;\n        }\n      }\n      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);\n      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);\n      s.strstart += used;\n      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;\n    }\n    s.block_start = s.strstart;\n  }\n  if (s.high_water < s.strstart) {\n    s.high_water = s.strstart;\n  }\n\n  /* If the last block was written to next_out, then done. */\n  if (last) {\n    return BS_FINISH_DONE;\n  }\n\n  /* If flushing and all input has been consumed, then done. */\n  if (flush !== Z_NO_FLUSH && flush !== Z_FINISH &&\n    s.strm.avail_in === 0 && s.strstart === s.block_start) {\n    return BS_BLOCK_DONE;\n  }\n\n  /* Fill the window with any remaining input. */\n  have = s.window_size - s.strstart;\n  if (s.strm.avail_in > have && s.block_start >= s.w_size) {\n    /* Slide the window down. */\n    s.block_start -= s.w_size;\n    s.strstart -= s.w_size;\n    //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n    if (s.matches < 2) {\n      s.matches++;       /* add a pending slide_hash() */\n    }\n    have += s.w_size;      /* more space now */\n    if (s.insert > s.strstart) {\n      s.insert = s.strstart;\n    }\n  }\n  if (have > s.strm.avail_in) {\n    have = s.strm.avail_in;\n  }\n  if (have) {\n    read_buf(s.strm, s.window, s.strstart, have);\n    s.strstart += have;\n    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;\n  }\n  if (s.high_water < s.strstart) {\n    s.high_water = s.strstart;\n  }\n\n  /* There was not enough avail_out to write a complete worthy or flushed\n   * stored block to next_out. Write a stored block to pending instead, if we\n   * have enough input for a worthy block, or if flushing and there is enough\n   * room for the remaining input as a stored block in the pending buffer.\n   */\n  have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n    /* maximum stored block length that will fit in pending: */\n  have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;\n  min_block = have > s.w_size ? s.w_size : have;\n  left = s.strstart - s.block_start;\n  if (left >= min_block ||\n     ((left || flush === Z_FINISH) && flush !== Z_NO_FLUSH &&\n     s.strm.avail_in === 0 && left <= have)) {\n    len = left > have ? have : left;\n    last = flush === Z_FINISH && s.strm.avail_in === 0 &&\n         len === left ? 1 : 0;\n    _tr_stored_block(s, s.block_start, len, last);\n    s.block_start += len;\n    flush_pending(s.strm);\n  }\n\n  /* We've done all we can with the available input and output. */\n  return last ? BS_FINISH_STARTED : BS_NEED_MORE;\n};\n\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nconst deflate_fast = (s, flush) => {\n\n  let hash_head;        /* head of the hash chain */\n  let bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nconst deflate_slow = (s, flush) => {\n\n  let hash_head;          /* head of hash chain */\n  let bflush;              /* set if current block must be flushed */\n\n  let max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n};\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nconst deflate_rle = (s, flush) => {\n\n  let bflush;            /* set if current block must be flushed */\n  let prev;              /* byte at distance one to match */\n  let scan, strend;      /* scan goes up to strend for length of run */\n\n  const _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nconst deflate_huff = (s, flush) => {\n\n  let bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nconst configuration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nconst lm_init = (s) => {\n\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n};\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);\n  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new Uint16Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.sym_buf = 0;        /* buffer for distances and literals/lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.sym_next = 0;      /* running index in sym_buf */\n  this.sym_end = 0;       /* symbol table full when sym_next reaches this */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\n/* =========================================================================\n * Check for a valid deflate stream state. Return 0 if ok, 1 if not.\n */\nconst deflateStateCheck = (strm) => {\n\n  if (!strm) {\n    return 1;\n  }\n  const s = strm.state;\n  if (!s || s.strm !== strm || (s.status !== INIT_STATE &&\n//#ifdef GZIP\n                                s.status !== GZIP_STATE &&\n//#endif\n                                s.status !== EXTRA_STATE &&\n                                s.status !== NAME_STATE &&\n                                s.status !== COMMENT_STATE &&\n                                s.status !== HCRC_STATE &&\n                                s.status !== BUSY_STATE &&\n                                s.status !== FINISH_STATE)) {\n    return 1;\n  }\n  return 0;\n};\n\n\nconst deflateResetKeep = (strm) => {\n\n  if (deflateStateCheck(strm)) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  const s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status =\n//#ifdef GZIP\n    s.wrap === 2 ? GZIP_STATE :\n//#endif\n    s.wrap ? INIT_STATE : BUSY_STATE;\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = -2;\n  _tr_init(s);\n  return Z_OK;\n};\n\n\nconst deflateReset = (strm) => {\n\n  const ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n};\n\n\nconst deflateSetHeader = (strm, head) => {\n\n  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {\n    return Z_STREAM_ERROR;\n  }\n  strm.state.gzhead = head;\n  return Z_OK;\n};\n\n\nconst deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  let wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  const s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n  s.status = INIT_STATE;     /* to pass state test in deflateReset() */\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new Uint8Array(s.w_size * 2);\n  s.head = new Uint16Array(s.hash_size);\n  s.prev = new Uint16Array(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  /* We overlay pending_buf and sym_buf. This works since the average size\n   * for length/distance pairs over any compressed block is assured to be 31\n   * bits or less.\n   *\n   * Analysis: The longest fixed codes are a length code of 8 bits plus 5\n   * extra bits, for lengths 131 to 257. The longest fixed distance codes are\n   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest\n   * possible fixed-codes length/distance pair is then 31 bits total.\n   *\n   * sym_buf starts one-fourth of the way into pending_buf. So there are\n   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol\n   * in sym_buf is three bytes -- two for the distance and one for the\n   * literal/length. As each symbol is consumed, the pointer to the next\n   * sym_buf value to read moves forward three bytes. From that symbol, up to\n   * 31 bits are written to pending_buf. The closest the written pending_buf\n   * bits gets to the next sym_buf symbol to read is just before the last\n   * code is written. At that time, 31*(n-2) bits have been written, just\n   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at\n   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1\n   * symbols are written.) The closest the writing gets to what is unread is\n   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and\n   * can range from 128 to 32768.\n   *\n   * Therefore, at a minimum, there are 142 bits of space between what is\n   * written and what is read in the overlain buffers, so the symbols cannot\n   * be overwritten by the compressed data. That space is actually 139 bits,\n   * due to the three-bit fixed-code block header.\n   *\n   * That covers the case where either Z_FIXED is specified, forcing fixed\n   * codes, or when the use of fixed codes is chosen, because that choice\n   * results in a smaller compressed block than dynamic codes. That latter\n   * condition then assures that the above analysis also covers all dynamic\n   * blocks. A dynamic-code block will only be chosen to be emitted if it has\n   * fewer bits than a fixed-code block would for the same set of symbols.\n   * Therefore its average symbol length is assured to be less than 31. So\n   * the compressed data for a dynamic block also cannot overwrite the\n   * symbols from which it is being constructed.\n   */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n  s.pending_buf = new Uint8Array(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->sym_buf = s->pending_buf + s->lit_bufsize;\n  s.sym_buf = s.lit_bufsize;\n\n  //s->sym_end = (s->lit_bufsize - 1) * 3;\n  s.sym_end = (s.lit_bufsize - 1) * 3;\n  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n};\n\nconst deflateInit = (strm, level) => {\n\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n};\n\n\n/* ========================================================================= */\nconst deflate = (strm, flush) => {\n\n  if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  const s = strm.state;\n\n  if (!strm.output ||\n      (strm.avail_in !== 0 && !strm.input) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  const old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Write the header */\n  if (s.status === INIT_STATE && s.wrap === 0) {\n    s.status = BUSY_STATE;\n  }\n  if (s.status === INIT_STATE) {\n    /* zlib header */\n    let header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n    let level_flags = -1;\n\n    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n      level_flags = 0;\n    } else if (s.level < 6) {\n      level_flags = 1;\n    } else if (s.level === 6) {\n      level_flags = 2;\n    } else {\n      level_flags = 3;\n    }\n    header |= (level_flags << 6);\n    if (s.strstart !== 0) { header |= PRESET_DICT; }\n    header += 31 - (header % 31);\n\n    putShortMSB(s, header);\n\n    /* Save the adler32 of the preset dictionary: */\n    if (s.strstart !== 0) {\n      putShortMSB(s, strm.adler >>> 16);\n      putShortMSB(s, strm.adler & 0xffff);\n    }\n    strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    s.status = BUSY_STATE;\n\n    /* Compression must start with an empty pending buffer */\n    flush_pending(strm);\n    if (s.pending !== 0) {\n      s.last_flush = -1;\n      return Z_OK;\n    }\n  }\n//#ifdef GZIP\n  if (s.status === GZIP_STATE) {\n    /* gzip header */\n    strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n    put_byte(s, 31);\n    put_byte(s, 139);\n    put_byte(s, 8);\n    if (!s.gzhead) { // s->gzhead == Z_NULL\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, s.level === 9 ? 2 :\n                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                   4 : 0));\n      put_byte(s, OS_CODE);\n      s.status = BUSY_STATE;\n\n      /* Compression must start with an empty pending buffer */\n      flush_pending(strm);\n      if (s.pending !== 0) {\n        s.last_flush = -1;\n        return Z_OK;\n      }\n    }\n    else {\n      put_byte(s, (s.gzhead.text ? 1 : 0) +\n                  (s.gzhead.hcrc ? 2 : 0) +\n                  (!s.gzhead.extra ? 0 : 4) +\n                  (!s.gzhead.name ? 0 : 8) +\n                  (!s.gzhead.comment ? 0 : 16)\n      );\n      put_byte(s, s.gzhead.time & 0xff);\n      put_byte(s, (s.gzhead.time >> 8) & 0xff);\n      put_byte(s, (s.gzhead.time >> 16) & 0xff);\n      put_byte(s, (s.gzhead.time >> 24) & 0xff);\n      put_byte(s, s.level === 9 ? 2 :\n                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                   4 : 0));\n      put_byte(s, s.gzhead.os & 0xff);\n      if (s.gzhead.extra && s.gzhead.extra.length) {\n        put_byte(s, s.gzhead.extra.length & 0xff);\n        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n      }\n      if (s.gzhead.hcrc) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n      }\n      s.gzindex = 0;\n      s.status = EXTRA_STATE;\n    }\n  }\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;\n      while (s.pending + left > s.pending_buf_size) {\n        let copy = s.pending_buf_size - s.pending;\n        // zmemcpy(s.pending_buf + s.pending,\n        //    s.gzhead.extra + s.gzindex, copy);\n        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);\n        s.pending = s.pending_buf_size;\n        //--- HCRC_UPDATE(beg) ---//\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        //---//\n        s.gzindex += copy;\n        flush_pending(strm);\n        if (s.pending !== 0) {\n          s.last_flush = -1;\n          return Z_OK;\n        }\n        beg = 0;\n        left -= copy;\n      }\n      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility\n      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11\n      let gzhead_extra = new Uint8Array(s.gzhead.extra);\n      // zmemcpy(s->pending_buf + s->pending,\n      //     s->gzhead->extra + s->gzindex, left);\n      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);\n      s.pending += left;\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n      s.gzindex = 0;\n    }\n    s.status = NAME_STATE;\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let val;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          //--- HCRC_UPDATE(beg) ---//\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          //---//\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK;\n          }\n          beg = 0;\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n      s.gzindex = 0;\n    }\n    s.status = COMMENT_STATE;\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let val;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          //--- HCRC_UPDATE(beg) ---//\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          //---//\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK;\n          }\n          beg = 0;\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n    }\n    s.status = HCRC_STATE;\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n        if (s.pending !== 0) {\n          s.last_flush = -1;\n          return Z_OK;\n        }\n      }\n      put_byte(s, strm.adler & 0xff);\n      put_byte(s, (strm.adler >> 8) & 0xff);\n      strm.adler = 0; //crc32(0L, Z_NULL, 0);\n    }\n    s.status = BUSY_STATE;\n\n    /* Compression must start with an empty pending buffer */\n    flush_pending(strm);\n    if (s.pending !== 0) {\n      s.last_flush = -1;\n      return Z_OK;\n    }\n  }\n//#endif\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    let bstate = s.level === 0 ? deflate_stored(s, flush) :\n                 s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :\n                 s.strategy === Z_RLE ? deflate_rle(s, flush) :\n                 configuration_table[s.level].func(s, flush);\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        _tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        _tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n};\n\n\nconst deflateEnd = (strm) => {\n\n  if (deflateStateCheck(strm)) {\n    return Z_STREAM_ERROR;\n  }\n\n  const status = strm.state.status;\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n};\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nconst deflateSetDictionary = (strm, dictionary) => {\n\n  let dictLength = dictionary.length;\n\n  if (deflateStateCheck(strm)) {\n    return Z_STREAM_ERROR;\n  }\n\n  const s = strm.state;\n  const wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    let tmpDict = new Uint8Array(s.w_size);\n    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  const avail = strm.avail_in;\n  const next = strm.next_in;\n  const input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    let str = s.strstart;\n    let n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n};\n\n\nmodule.exports.deflateInit = deflateInit;\nmodule.exports.deflateInit2 = deflateInit2;\nmodule.exports.deflateReset = deflateReset;\nmodule.exports.deflateResetKeep = deflateResetKeep;\nmodule.exports.deflateSetHeader = deflateSetHeader;\nmodule.exports.deflate = deflate;\nmodule.exports.deflateEnd = deflateEnd;\nmodule.exports.deflateSetDictionary = deflateSetDictionary;\nmodule.exports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.deflateBound = deflateBound;\nmodule.exports.deflateCopy = deflateCopy;\nmodule.exports.deflateGetDictionary = deflateGetDictionary;\nmodule.exports.deflateParams = deflateParams;\nmodule.exports.deflatePending = deflatePending;\nmodule.exports.deflatePrime = deflatePrime;\nmodule.exports.deflateTune = deflateTune;\n*/\n"],"mappings":"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","ignoreList":[]}