{"version":3,"file":"node_modules/pako/dist/pako_deflate.js","names":["global","factory","exports","module","define","amd","globalThis","self","pako","this","zero$1","buf","len","length","LITERALS$1","L_CODES$1","D_CODES$1","MAX_BITS$1","extra_lbits","Uint8Array","extra_dbits","extra_blbits","bl_order","static_ltree","Array","static_dtree","_dist_code","_length_code","MAX_MATCH$1","base_length","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","has_stree","static_l_desc","static_d_desc","static_bl_desc","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","s","w","pending_buf","pending","send_bits","value","bi_valid","bi_buf","send_code","c","tree","bi_reverse","code","res","gen_codes","bl_count","next_code","bits","n","init_block","dyn_ltree","dyn_dtree","bl_tree","END_BLOCK","opt_len","static_len","sym_next","matches","bi_windup","smaller","m","depth","_n2","_m2","pqdownheap","k","v","heap","j","heap_len","compress_block","ltree","dtree","lc","extra","sx","sym_buf","build_tree","desc","stree","node","heap_max","base","h","xbits","f","overflow","gen_bitlen","scan_tree","curlen","prevlen","nextlen","count","max_count","min_count","REP_3_6","REPZ_3_10","REPZ_11_138","send_tree","static_init_done","_tr_stored_block$1","stored_len","last","set","window","subarray","_tr_flush_block_1","opt_lenb","static_lenb","max_blindex","level","strm","data_type","block_mask","detect_data_type","l_desc","d_desc","bl_desc","BL_CODES$1","build_bl_tree","strategy","lcodes","dcodes","blcodes","rank","send_all_trees","trees","_tr_init","LENGTH_CODES$1","tr_static_init","_tr_stored_block","_tr_flush_block","_tr_tally","sym_end","_tr_align","STATIC_TREES","bi_flush","adler32_1","adler","pos","s1","s2","crcTable","Uint32Array","table","makeTable","crc32_1","crc","t","end","i","messages","constants$1","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_TREES","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_NO_COMPRESSION","Z_BEST_SPEED","Z_BEST_COMPRESSION","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","Z_BINARY","Z_TEXT","Z_UNKNOWN","Z_DEFLATED","Z_NO_FLUSH$1","Z_FULL_FLUSH$1","Z_FINISH$1","Z_OK$1","Z_STREAM_END$1","Z_DEFAULT_COMPRESSION$1","Z_DEFAULT_STRATEGY$1","Z_DEFLATED$1","MAX_MATCH","MIN_LOOKAHEAD","INIT_STATE","BUSY_STATE","FINISH_STATE","err","errorCode","msg","zero","slide_hash","p","wsize","w_size","hash_size","head","prev","HASH","data","hash_shift","hash_mask","flush_pending","state","avail_out","output","pending_out","next_out","total_out","flush_block_only","block_start","strstart","put_byte","b","putShortMSB","read_buf","start","size","avail_in","input","next_in","wrap","total_in","longest_match","cur_match","match","chain_length","max_chain_length","scan","best_len","prev_length","nice_match","limit","_win","wmask","w_mask","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","_w_size","more","str","window_size","insert","ins_h","deflate_stored","flush","left","have","min_block","pending_buf_size","used","high_water","deflate_fast","hash_head","bflush","match_length","max_lazy_match","MIN_MATCH","deflate_slow","max_insert","prev_match","match_available","Config","good_length","max_lazy","nice_length","max_chain","func","configuration_table","DeflateState","status","gzhead","gzindex","method","last_flush","w_bits","hash_bits","Uint16Array","HEAP_SIZE","MAX_BITS","lit_bufsize","deflateStateCheck","deflateResetKeep","deflateReset","ret","deflateInit2","windowBits","memLevel","deflate_1$1","deflateInit","deflateSetHeader","deflate","old_flush","header","level_flags","text","hcrc","name","comment","time","os","beg","copy","gzhead_extra","val","charCodeAt","bstate","deflate_huff","deflate_rle","deflateEnd","deflateSetDictionary","dictionary","dictLength","tmpDict","avail","next","deflateInfo","_has","obj","key","Object","prototype","hasOwnProperty","call","common","assign","sources","slice","arguments","source","shift","TypeError","flattenChunks","chunks","l","result","chunk","STR_APPLY_UIA_OK","String","fromCharCode","apply","__","_utf8len","q","strings","string2buf","TextEncoder","encode","c2","m_pos","str_len","buf_len","buf2string","max","TextDecoder","decode","out","utf16buf","c_len","buf2binstring","utf8border","zstream","toString","Deflate","options","chunkSize","opt","raw","gzip","ended","Error","dict","_dict_set","deflator","push","flush_mode","_flush_mode","onData","onEnd","Deflate_1","deflate_2","deflateRaw_1","gzip_1","constants","deflate_1","deflateRaw","defineProperty"],"sources":["node_modules/pako/dist/pako_deflate.js"],"sourcesContent":["\n/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.pako = {}));\n})(this, (function (exports) { 'use strict';\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  /* eslint-disable space-unary-ops */\n\n  /* Public constants ==========================================================*/\n  /* ===========================================================================*/\n\n\n  //const Z_FILTERED          = 1;\n  //const Z_HUFFMAN_ONLY      = 2;\n  //const Z_RLE               = 3;\n  const Z_FIXED$1               = 4;\n  //const Z_DEFAULT_STRATEGY  = 0;\n\n  /* Possible values of the data_type field (though see inflate()) */\n  const Z_BINARY              = 0;\n  const Z_TEXT                = 1;\n  //const Z_ASCII             = 1; // = Z_TEXT\n  const Z_UNKNOWN$1             = 2;\n\n  /*============================================================================*/\n\n\n  function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n  // From zutil.h\n\n  const STORED_BLOCK = 0;\n  const STATIC_TREES = 1;\n  const DYN_TREES    = 2;\n  /* The three kinds of block type */\n\n  const MIN_MATCH$1    = 3;\n  const MAX_MATCH$1    = 258;\n  /* The minimum and maximum match lengths */\n\n  // From deflate.h\n  /* ===========================================================================\n   * Internal compression state.\n   */\n\n  const LENGTH_CODES$1  = 29;\n  /* number of length codes, not counting the special END_BLOCK code */\n\n  const LITERALS$1      = 256;\n  /* number of literal bytes 0..255 */\n\n  const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;\n  /* number of Literal or Length codes, including the END_BLOCK code */\n\n  const D_CODES$1       = 30;\n  /* number of distance codes */\n\n  const BL_CODES$1      = 19;\n  /* number of codes used to transfer the bit lengths */\n\n  const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;\n  /* maximum heap size */\n\n  const MAX_BITS$1      = 15;\n  /* All codes must not exceed MAX_BITS bits */\n\n  const Buf_size      = 16;\n  /* size of bit buffer in bi_buf */\n\n\n  /* ===========================================================================\n   * Constants\n   */\n\n  const MAX_BL_BITS = 7;\n  /* Bit length codes must not exceed MAX_BL_BITS bits */\n\n  const END_BLOCK   = 256;\n  /* end of block literal code */\n\n  const REP_3_6     = 16;\n  /* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n  const REPZ_3_10   = 17;\n  /* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n  const REPZ_11_138 = 18;\n  /* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n  /* eslint-disable comma-spacing,array-bracket-spacing */\n  const extra_lbits =   /* extra bits for each length code */\n    new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);\n\n  const extra_dbits =   /* extra bits for each distance code */\n    new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);\n\n  const extra_blbits =  /* extra bits for each bit length code */\n    new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);\n\n  const bl_order =\n    new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);\n  /* eslint-enable comma-spacing,array-bracket-spacing */\n\n  /* The lengths of the bit length codes are sent in order of decreasing\n   * probability, to avoid transmitting the lengths for unused bit length codes.\n   */\n\n  /* ===========================================================================\n   * Local data. These are initialized only once.\n   */\n\n  // We pre-fill arrays with 0 to avoid uninitialized gaps\n\n  const DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n  // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n  const static_ltree  = new Array((L_CODES$1 + 2) * 2);\n  zero$1(static_ltree);\n  /* The static literal tree. Since the bit lengths are imposed, there is no\n   * need for the L_CODES extra codes used during heap construction. However\n   * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n   * below).\n   */\n\n  const static_dtree  = new Array(D_CODES$1 * 2);\n  zero$1(static_dtree);\n  /* The static distance tree. (Actually a trivial tree since all codes use\n   * 5 bits.)\n   */\n\n  const _dist_code    = new Array(DIST_CODE_LEN);\n  zero$1(_dist_code);\n  /* Distance codes. The first 256 values correspond to the distances\n   * 3 .. 258, the last 256 values correspond to the top 8 bits of\n   * the 15 bit distances.\n   */\n\n  const _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);\n  zero$1(_length_code);\n  /* length code for each normalized match length (0 == MIN_MATCH) */\n\n  const base_length   = new Array(LENGTH_CODES$1);\n  zero$1(base_length);\n  /* First normalized length for each code (0 = MIN_MATCH) */\n\n  const base_dist     = new Array(D_CODES$1);\n  zero$1(base_dist);\n  /* First normalized distance for each code (0 = distance of 1) */\n\n\n  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n    this.static_tree  = static_tree;  /* static tree or NULL */\n    this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n    this.extra_base   = extra_base;   /* base index for extra_bits */\n    this.elems        = elems;        /* max number of elements in the tree */\n    this.max_length   = max_length;   /* max bit length for the codes */\n\n    // show if `static_tree` has data or dummy - needed for monomorphic objects\n    this.has_stree    = static_tree && static_tree.length;\n  }\n\n\n  let static_l_desc;\n  let static_d_desc;\n  let static_bl_desc;\n\n\n  function TreeDesc(dyn_tree, stat_desc) {\n    this.dyn_tree = dyn_tree;     /* the dynamic tree */\n    this.max_code = 0;            /* largest code with non zero frequency */\n    this.stat_desc = stat_desc;   /* the corresponding static tree */\n  }\n\n\n\n  const d_code = (dist) => {\n\n    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n  };\n\n\n  /* ===========================================================================\n   * Output a short LSB first on the stream.\n   * IN assertion: there is enough room in pendingBuf.\n   */\n  const put_short = (s, w) => {\n  //    put_byte(s, (uch)((w) & 0xff));\n  //    put_byte(s, (uch)((ush)(w) >> 8));\n    s.pending_buf[s.pending++] = (w) & 0xff;\n    s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n  };\n\n\n  /* ===========================================================================\n   * Send a value on a given number of bits.\n   * IN assertion: length <= 16 and value fits in length bits.\n   */\n  const send_bits = (s, value, length) => {\n\n    if (s.bi_valid > (Buf_size - length)) {\n      s.bi_buf |= (value << s.bi_valid) & 0xffff;\n      put_short(s, s.bi_buf);\n      s.bi_buf = value >> (Buf_size - s.bi_valid);\n      s.bi_valid += length - Buf_size;\n    } else {\n      s.bi_buf |= (value << s.bi_valid) & 0xffff;\n      s.bi_valid += length;\n    }\n  };\n\n\n  const send_code = (s, c, tree) => {\n\n    send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n  };\n\n\n  /* ===========================================================================\n   * Reverse the first len bits of a code, using straightforward code (a faster\n   * method would use a table)\n   * IN assertion: 1 <= len <= 15\n   */\n  const bi_reverse = (code, len) => {\n\n    let res = 0;\n    do {\n      res |= code & 1;\n      code >>>= 1;\n      res <<= 1;\n    } while (--len > 0);\n    return res >>> 1;\n  };\n\n\n  /* ===========================================================================\n   * Flush the bit buffer, keeping at most 7 bits in it.\n   */\n  const bi_flush = (s) => {\n\n    if (s.bi_valid === 16) {\n      put_short(s, s.bi_buf);\n      s.bi_buf = 0;\n      s.bi_valid = 0;\n\n    } else if (s.bi_valid >= 8) {\n      s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n      s.bi_buf >>= 8;\n      s.bi_valid -= 8;\n    }\n  };\n\n\n  /* ===========================================================================\n   * Compute the optimal bit lengths for a tree and update the total bit length\n   * for the current block.\n   * IN assertion: the fields freq and dad are set, heap[heap_max] and\n   *    above are the tree nodes sorted by increasing frequency.\n   * OUT assertions: the field len is set to the optimal bit length, the\n   *     array bl_count contains the frequencies for each bit length.\n   *     The length opt_len is updated; static_len is also updated if stree is\n   *     not null.\n   */\n  const gen_bitlen = (s, desc) => {\n  //    deflate_state *s;\n  //    tree_desc *desc;    /* the tree descriptor */\n\n    const tree            = desc.dyn_tree;\n    const max_code        = desc.max_code;\n    const stree           = desc.stat_desc.static_tree;\n    const has_stree       = desc.stat_desc.has_stree;\n    const extra           = desc.stat_desc.extra_bits;\n    const base            = desc.stat_desc.extra_base;\n    const max_length      = desc.stat_desc.max_length;\n    let h;              /* heap index */\n    let n, m;           /* iterate over the tree elements */\n    let bits;           /* bit length */\n    let xbits;          /* extra bits */\n    let f;              /* frequency */\n    let overflow = 0;   /* number of elements with bit length too large */\n\n    for (bits = 0; bits <= MAX_BITS$1; bits++) {\n      s.bl_count[bits] = 0;\n    }\n\n    /* In a first pass, compute the optimal bit lengths (which may\n     * overflow in the case of the bit length tree).\n     */\n    tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n    for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {\n      n = s.heap[h];\n      bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n      if (bits > max_length) {\n        bits = max_length;\n        overflow++;\n      }\n      tree[n * 2 + 1]/*.Len*/ = bits;\n      /* We overwrite tree[n].Dad which is no longer needed */\n\n      if (n > max_code) { continue; } /* not a leaf node */\n\n      s.bl_count[bits]++;\n      xbits = 0;\n      if (n >= base) {\n        xbits = extra[n - base];\n      }\n      f = tree[n * 2]/*.Freq*/;\n      s.opt_len += f * (bits + xbits);\n      if (has_stree) {\n        s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n      }\n    }\n    if (overflow === 0) { return; }\n\n    // Tracev((stderr,\"\\nbit length overflow\\n\"));\n    /* This happens for example on obj2 and pic of the Calgary corpus */\n\n    /* Find the first bit length which could increase: */\n    do {\n      bits = max_length - 1;\n      while (s.bl_count[bits] === 0) { bits--; }\n      s.bl_count[bits]--;      /* move one leaf down the tree */\n      s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n      s.bl_count[max_length]--;\n      /* The brother of the overflow item also moves one step up,\n       * but this does not affect bl_count[max_length]\n       */\n      overflow -= 2;\n    } while (overflow > 0);\n\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n     * lengths instead of fixing only the wrong ones. This idea is taken\n     * from 'ar' written by Haruhiko Okumura.)\n     */\n    for (bits = max_length; bits !== 0; bits--) {\n      n = s.bl_count[bits];\n      while (n !== 0) {\n        m = s.heap[--h];\n        if (m > max_code) { continue; }\n        if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n          // Tracev((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n          s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n          tree[m * 2 + 1]/*.Len*/ = bits;\n        }\n        n--;\n      }\n    }\n  };\n\n\n  /* ===========================================================================\n   * Generate the codes for a given tree and bit counts (which need not be\n   * optimal).\n   * IN assertion: the array bl_count contains the bit length statistics for\n   * the given tree and the field len is set for all tree elements.\n   * OUT assertion: the field code is set for all tree elements of non\n   *     zero code length.\n   */\n  const gen_codes = (tree, max_code, bl_count) => {\n  //    ct_data *tree;             /* the tree to decorate */\n  //    int max_code;              /* largest code with non zero frequency */\n  //    ushf *bl_count;            /* number of codes at each bit length */\n\n    const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */\n    let code = 0;              /* running code value */\n    let bits;                  /* bit index */\n    let n;                     /* code index */\n\n    /* The distribution counts are first used to generate the code values\n     * without bit reversal.\n     */\n    for (bits = 1; bits <= MAX_BITS$1; bits++) {\n      code = (code + bl_count[bits - 1]) << 1;\n      next_code[bits] = code;\n    }\n    /* Check that the bit counts in bl_count are consistent. The last code\n     * must be all ones.\n     */\n    //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n    //        \"inconsistent bit counts\");\n    //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n    for (n = 0;  n <= max_code; n++) {\n      let len = tree[n * 2 + 1]/*.Len*/;\n      if (len === 0) { continue; }\n      /* Now reverse the bits */\n      tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n      //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n      //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n    }\n  };\n\n\n  /* ===========================================================================\n   * Initialize the various 'constant' tables.\n   */\n  const tr_static_init = () => {\n\n    let n;        /* iterates over tree elements */\n    let bits;     /* bit counter */\n    let length;   /* length value */\n    let code;     /* code value */\n    let dist;     /* distance index */\n    const bl_count = new Array(MAX_BITS$1 + 1);\n    /* number of codes at each bit length for an optimal tree */\n\n    // do check in _tr_init()\n    //if (static_init_done) return;\n\n    /* For some embedded targets, global variables are not initialized: */\n  /*#ifdef NO_INIT_GLOBAL_POINTERS\n    static_l_desc.static_tree = static_ltree;\n    static_l_desc.extra_bits = extra_lbits;\n    static_d_desc.static_tree = static_dtree;\n    static_d_desc.extra_bits = extra_dbits;\n    static_bl_desc.extra_bits = extra_blbits;\n  #endif*/\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES$1 - 1; code++) {\n      base_length[code] = length;\n      for (n = 0; n < (1 << extra_lbits[code]); n++) {\n        _length_code[length++] = code;\n      }\n    }\n    //Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    _length_code[length - 1] = code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0; code < 16; code++) {\n      base_dist[code] = dist;\n      for (n = 0; n < (1 << extra_dbits[code]); n++) {\n        _dist_code[dist++] = code;\n      }\n    }\n    //Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for (; code < D_CODES$1; code++) {\n      base_dist[code] = dist << 7;\n      for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n        _dist_code[256 + dist++] = code;\n      }\n    }\n    //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS$1; bits++) {\n      bl_count[bits] = 0;\n    }\n\n    n = 0;\n    while (n <= 143) {\n      static_ltree[n * 2 + 1]/*.Len*/ = 8;\n      n++;\n      bl_count[8]++;\n    }\n    while (n <= 255) {\n      static_ltree[n * 2 + 1]/*.Len*/ = 9;\n      n++;\n      bl_count[9]++;\n    }\n    while (n <= 279) {\n      static_ltree[n * 2 + 1]/*.Len*/ = 7;\n      n++;\n      bl_count[7]++;\n    }\n    while (n <= 287) {\n      static_ltree[n * 2 + 1]/*.Len*/ = 8;\n      n++;\n      bl_count[8]++;\n    }\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes(static_ltree, L_CODES$1 + 1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES$1; n++) {\n      static_dtree[n * 2 + 1]/*.Len*/ = 5;\n      static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n    }\n\n    // Now data ready and we can init static trees\n    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);\n    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);\n    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);\n\n    //static_init_done = true;\n  };\n\n\n  /* ===========================================================================\n   * Initialize a new block.\n   */\n  const init_block = (s) => {\n\n    let n; /* iterates over tree elements */\n\n    /* Initialize the trees. */\n    for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n    for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n    for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n    s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n    s.opt_len = s.static_len = 0;\n    s.sym_next = s.matches = 0;\n  };\n\n\n  /* ===========================================================================\n   * Flush the bit buffer and align the output on a byte boundary\n   */\n  const bi_windup = (s) =>\n  {\n    if (s.bi_valid > 8) {\n      put_short(s, s.bi_buf);\n    } else if (s.bi_valid > 0) {\n      //put_byte(s, (Byte)s->bi_buf);\n      s.pending_buf[s.pending++] = s.bi_buf;\n    }\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n  };\n\n  /* ===========================================================================\n   * Compares to subtrees, using the tree depth as tie breaker when\n   * the subtrees have equal frequency. This minimizes the worst case length.\n   */\n  const smaller = (tree, n, m, depth) => {\n\n    const _n2 = n * 2;\n    const _m2 = m * 2;\n    return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n           (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n  };\n\n  /* ===========================================================================\n   * Restore the heap property by moving down the tree starting at node k,\n   * exchanging a node with the smallest of its two sons if necessary, stopping\n   * when the heap property is re-established (each father smaller than its\n   * two sons).\n   */\n  const pqdownheap = (s, tree, k) => {\n  //    deflate_state *s;\n  //    ct_data *tree;  /* the tree to restore */\n  //    int k;               /* node to move down */\n\n    const v = s.heap[k];\n    let j = k << 1;  /* left son of k */\n    while (j <= s.heap_len) {\n      /* Set j to the smallest of the two sons: */\n      if (j < s.heap_len &&\n        smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n        j++;\n      }\n      /* Exit if v is smaller than both sons */\n      if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n      /* Exchange v with the smallest son */\n      s.heap[k] = s.heap[j];\n      k = j;\n\n      /* And continue down the tree, setting j to the left son of k */\n      j <<= 1;\n    }\n    s.heap[k] = v;\n  };\n\n\n  // inlined manually\n  // const SMALLEST = 1;\n\n  /* ===========================================================================\n   * Send the block data compressed using the given Huffman trees\n   */\n  const compress_block = (s, ltree, dtree) => {\n  //    deflate_state *s;\n  //    const ct_data *ltree; /* literal tree */\n  //    const ct_data *dtree; /* distance tree */\n\n    let dist;           /* distance of matched string */\n    let lc;             /* match length or unmatched char (if dist == 0) */\n    let sx = 0;         /* running index in sym_buf */\n    let code;           /* the code to send */\n    let extra;          /* number of extra bits to send */\n\n    if (s.sym_next !== 0) {\n      do {\n        dist = s.pending_buf[s.sym_buf + sx++] & 0xff;\n        dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;\n        lc = s.pending_buf[s.sym_buf + sx++];\n        if (dist === 0) {\n          send_code(s, lc, ltree); /* send a literal byte */\n          //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n        } else {\n          /* Here, lc is the match length - MIN_MATCH */\n          code = _length_code[lc];\n          send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */\n          extra = extra_lbits[code];\n          if (extra !== 0) {\n            lc -= base_length[code];\n            send_bits(s, lc, extra);       /* send the extra length bits */\n          }\n          dist--; /* dist is now the match distance - 1 */\n          code = d_code(dist);\n          //Assert (code < D_CODES, \"bad d_code\");\n\n          send_code(s, code, dtree);       /* send the distance code */\n          extra = extra_dbits[code];\n          if (extra !== 0) {\n            dist -= base_dist[code];\n            send_bits(s, dist, extra);   /* send the extra distance bits */\n          }\n        } /* literal or match pair ? */\n\n        /* Check that the overlay between pending_buf and sym_buf is ok: */\n        //Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\");\n\n      } while (sx < s.sym_next);\n    }\n\n    send_code(s, END_BLOCK, ltree);\n  };\n\n\n  /* ===========================================================================\n   * Construct one Huffman tree and assigns the code bit strings and lengths.\n   * Update the total bit length for the current block.\n   * IN assertion: the field freq is set for all tree elements.\n   * OUT assertions: the fields len and code are set to the optimal bit length\n   *     and corresponding code. The length opt_len is updated; static_len is\n   *     also updated if stree is not null. The field max_code is set.\n   */\n  const build_tree = (s, desc) => {\n  //    deflate_state *s;\n  //    tree_desc *desc; /* the tree descriptor */\n\n    const tree     = desc.dyn_tree;\n    const stree    = desc.stat_desc.static_tree;\n    const has_stree = desc.stat_desc.has_stree;\n    const elems    = desc.stat_desc.elems;\n    let n, m;          /* iterate over heap elements */\n    let max_code = -1; /* largest code with non zero frequency */\n    let node;          /* new node being created */\n\n    /* Construct the initial heap, with least frequent element in\n     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n     * heap[0] is not used.\n     */\n    s.heap_len = 0;\n    s.heap_max = HEAP_SIZE$1;\n\n    for (n = 0; n < elems; n++) {\n      if (tree[n * 2]/*.Freq*/ !== 0) {\n        s.heap[++s.heap_len] = max_code = n;\n        s.depth[n] = 0;\n\n      } else {\n        tree[n * 2 + 1]/*.Len*/ = 0;\n      }\n    }\n\n    /* The pkzip format requires that at least one distance code exists,\n     * and that at least one bit should be sent even if there is only one\n     * possible code. So to avoid special checks later on we force at least\n     * two codes of non zero frequency.\n     */\n    while (s.heap_len < 2) {\n      node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n      tree[node * 2]/*.Freq*/ = 1;\n      s.depth[node] = 0;\n      s.opt_len--;\n\n      if (has_stree) {\n        s.static_len -= stree[node * 2 + 1]/*.Len*/;\n      }\n      /* node is 0 or 1 so it does not have extra bits */\n    }\n    desc.max_code = max_code;\n\n    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n     * establish sub-heaps of increasing lengths:\n     */\n    for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n    /* Construct the Huffman tree by repeatedly combining the least two\n     * frequent nodes.\n     */\n    node = elems;              /* next internal node of the tree */\n    do {\n      //pqremove(s, tree, n);  /* n = node of least frequency */\n      /*** pqremove ***/\n      n = s.heap[1/*SMALLEST*/];\n      s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n      pqdownheap(s, tree, 1/*SMALLEST*/);\n      /***/\n\n      m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n      s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n      s.heap[--s.heap_max] = m;\n\n      /* Create a new node father of n and m */\n      tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n      tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n      /* and insert the new node in the heap */\n      s.heap[1/*SMALLEST*/] = node++;\n      pqdownheap(s, tree, 1/*SMALLEST*/);\n\n    } while (s.heap_len >= 2);\n\n    s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n    /* At this point, the fields freq and dad are set. We can now\n     * generate the bit lengths.\n     */\n    gen_bitlen(s, desc);\n\n    /* The field len is now set, we can generate the bit codes */\n    gen_codes(tree, max_code, s.bl_count);\n  };\n\n\n  /* ===========================================================================\n   * Scan a literal or distance tree to determine the frequencies of the codes\n   * in the bit length tree.\n   */\n  const scan_tree = (s, tree, max_code) => {\n  //    deflate_state *s;\n  //    ct_data *tree;   /* the tree to be scanned */\n  //    int max_code;    /* and its largest code of non zero frequency */\n\n    let n;                     /* iterates over all tree elements */\n    let prevlen = -1;          /* last emitted length */\n    let curlen;                /* length of current code */\n\n    let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n    let count = 0;             /* repeat count of the current code */\n    let max_count = 7;         /* max repeat count */\n    let min_count = 4;         /* min repeat count */\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n    }\n    tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n    for (n = 0; n <= max_code; n++) {\n      curlen = nextlen;\n      nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n      if (++count < max_count && curlen === nextlen) {\n        continue;\n\n      } else if (count < min_count) {\n        s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n      } else if (curlen !== 0) {\n\n        if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n        s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n      } else if (count <= 10) {\n        s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n      } else {\n        s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n      }\n\n      count = 0;\n      prevlen = curlen;\n\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n\n      } else if (curlen === nextlen) {\n        max_count = 6;\n        min_count = 3;\n\n      } else {\n        max_count = 7;\n        min_count = 4;\n      }\n    }\n  };\n\n\n  /* ===========================================================================\n   * Send a literal or distance tree in compressed form, using the codes in\n   * bl_tree.\n   */\n  const send_tree = (s, tree, max_code) => {\n  //    deflate_state *s;\n  //    ct_data *tree; /* the tree to be scanned */\n  //    int max_code;       /* and its largest code of non zero frequency */\n\n    let n;                     /* iterates over all tree elements */\n    let prevlen = -1;          /* last emitted length */\n    let curlen;                /* length of current code */\n\n    let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n    let count = 0;             /* repeat count of the current code */\n    let max_count = 7;         /* max repeat count */\n    let min_count = 4;         /* min repeat count */\n\n    /* tree[max_code+1].Len = -1; */  /* guard already set */\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n    }\n\n    for (n = 0; n <= max_code; n++) {\n      curlen = nextlen;\n      nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n      if (++count < max_count && curlen === nextlen) {\n        continue;\n\n      } else if (count < min_count) {\n        do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n      } else if (curlen !== 0) {\n        if (curlen !== prevlen) {\n          send_code(s, curlen, s.bl_tree);\n          count--;\n        }\n        //Assert(count >= 3 && count <= 6, \" 3_6?\");\n        send_code(s, REP_3_6, s.bl_tree);\n        send_bits(s, count - 3, 2);\n\n      } else if (count <= 10) {\n        send_code(s, REPZ_3_10, s.bl_tree);\n        send_bits(s, count - 3, 3);\n\n      } else {\n        send_code(s, REPZ_11_138, s.bl_tree);\n        send_bits(s, count - 11, 7);\n      }\n\n      count = 0;\n      prevlen = curlen;\n      if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n\n      } else if (curlen === nextlen) {\n        max_count = 6;\n        min_count = 3;\n\n      } else {\n        max_count = 7;\n        min_count = 4;\n      }\n    }\n  };\n\n\n  /* ===========================================================================\n   * Construct the Huffman tree for the bit lengths and return the index in\n   * bl_order of the last bit length code to send.\n   */\n  const build_bl_tree = (s) => {\n\n    let max_blindex;  /* index of last bit length code of non zero freq */\n\n    /* Determine the bit length frequencies for literal and distance trees */\n    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n    /* Build the bit length tree: */\n    build_tree(s, s.bl_desc);\n    /* opt_len now includes the length of the tree representations, except\n     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n     */\n\n    /* Determine the number of bit length codes to send. The pkzip format\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\n     * 3 but the actual value used is 4.)\n     */\n    for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {\n      if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n        break;\n      }\n    }\n    /* Update opt_len to include the bit length tree and counts */\n    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n    //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n    //        s->opt_len, s->static_len));\n\n    return max_blindex;\n  };\n\n\n  /* ===========================================================================\n   * Send the header for a block using dynamic Huffman trees: the counts, the\n   * lengths of the bit length codes, the literal tree and the distance tree.\n   * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n   */\n  const send_all_trees = (s, lcodes, dcodes, blcodes) => {\n  //    deflate_state *s;\n  //    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n\n    let rank;                    /* index in bl_order */\n\n    //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n    //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n    //        \"too many codes\");\n    //Tracev((stderr, \"\\nbl counts: \"));\n    send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n    send_bits(s, dcodes - 1,   5);\n    send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n    for (rank = 0; rank < blcodes; rank++) {\n      //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n    }\n    //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n    //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n    //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n  };\n\n\n  /* ===========================================================================\n   * Check if the data type is TEXT or BINARY, using the following algorithm:\n   * - TEXT if the two conditions below are satisfied:\n   *    a) There are no non-portable control characters belonging to the\n   *       \"block list\" (0..6, 14..25, 28..31).\n   *    b) There is at least one printable character belonging to the\n   *       \"allow list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n   * - BINARY otherwise.\n   * - The following partially-portable control characters form a\n   *   \"gray list\" that is ignored in this detection algorithm:\n   *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n   * IN assertion: the fields Freq of dyn_ltree are set.\n   */\n  const detect_data_type = (s) => {\n    /* block_mask is the bit mask of block-listed bytes\n     * set bits 0..6, 14..25, and 28..31\n     * 0xf3ffc07f = binary 11110011111111111100000001111111\n     */\n    let block_mask = 0xf3ffc07f;\n    let n;\n\n    /* Check for non-textual (\"block-listed\") bytes. */\n    for (n = 0; n <= 31; n++, block_mask >>>= 1) {\n      if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n        return Z_BINARY;\n      }\n    }\n\n    /* Check for textual (\"allow-listed\") bytes. */\n    if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n        s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n    for (n = 32; n < LITERALS$1; n++) {\n      if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n        return Z_TEXT;\n      }\n    }\n\n    /* There are no \"block-listed\" or \"allow-listed\" bytes:\n     * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n     */\n    return Z_BINARY;\n  };\n\n\n  let static_init_done = false;\n\n  /* ===========================================================================\n   * Initialize the tree data structures for a new zlib stream.\n   */\n  const _tr_init$1 = (s) =>\n  {\n\n    if (!static_init_done) {\n      tr_static_init();\n      static_init_done = true;\n    }\n\n    s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n    s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n    /* Initialize the first block of the first file: */\n    init_block(s);\n  };\n\n\n  /* ===========================================================================\n   * Send a stored block\n   */\n  const _tr_stored_block$1 = (s, buf, stored_len, last) => {\n  //DeflateState *s;\n  //charf *buf;       /* input block */\n  //ulg stored_len;   /* length of input block */\n  //int last;         /* one if this is the last block for a file */\n\n    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n    bi_windup(s);        /* align on byte boundary */\n    put_short(s, stored_len);\n    put_short(s, ~stored_len);\n    if (stored_len) {\n      s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);\n    }\n    s.pending += stored_len;\n  };\n\n\n  /* ===========================================================================\n   * Send one empty static block to give enough lookahead for inflate.\n   * This takes 10 bits, of which 7 may remain in the bit buffer.\n   */\n  const _tr_align$1 = (s) => {\n    send_bits(s, STATIC_TREES << 1, 3);\n    send_code(s, END_BLOCK, static_ltree);\n    bi_flush(s);\n  };\n\n\n  /* ===========================================================================\n   * Determine the best encoding for the current block: dynamic trees, static\n   * trees or store, and write out the encoded block.\n   */\n  const _tr_flush_block$1 = (s, buf, stored_len, last) => {\n  //DeflateState *s;\n  //charf *buf;       /* input block, or NULL if too old */\n  //ulg stored_len;   /* length of input block */\n  //int last;         /* one if this is the last block for a file */\n\n    let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n    let max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n    /* Build the Huffman trees unless a stored block is forced */\n    if (s.level > 0) {\n\n      /* Check if the file is binary or text */\n      if (s.strm.data_type === Z_UNKNOWN$1) {\n        s.strm.data_type = detect_data_type(s);\n      }\n\n      /* Construct the literal and distance trees */\n      build_tree(s, s.l_desc);\n      // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n      //        s->static_len));\n\n      build_tree(s, s.d_desc);\n      // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n      //        s->static_len));\n      /* At this point, opt_len and static_len are the total bit lengths of\n       * the compressed block data, excluding the tree representations.\n       */\n\n      /* Build the bit length tree for the above two trees, and get the index\n       * in bl_order of the last bit length code to send.\n       */\n      max_blindex = build_bl_tree(s);\n\n      /* Determine the best encoding. Compute the block lengths in bytes. */\n      opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n      static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n      // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n      //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n      //        s->sym_next / 3));\n\n      if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n    } else {\n      // Assert(buf != (char*)0, \"lost buf\");\n      opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n    }\n\n    if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n      /* 4: two words for the lengths */\n\n      /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n       * Otherwise we can't have processed more than WSIZE input bytes since\n       * the last block flush, because compression would have been\n       * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n       * transform a block into a stored block.\n       */\n      _tr_stored_block$1(s, buf, stored_len, last);\n\n    } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {\n\n      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n      compress_block(s, static_ltree, static_dtree);\n\n    } else {\n      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n      compress_block(s, s.dyn_ltree, s.dyn_dtree);\n    }\n    // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n    /* The above check is made mod 2^32, for files larger than 512 MB\n     * and uLong implemented on 32 bits.\n     */\n    init_block(s);\n\n    if (last) {\n      bi_windup(s);\n    }\n    // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n    //       s->compressed_len-7*last));\n  };\n\n  /* ===========================================================================\n   * Save the match info and tally the frequency counts. Return true if\n   * the current block must be flushed.\n   */\n  const _tr_tally$1 = (s, dist, lc) => {\n  //    deflate_state *s;\n  //    unsigned dist;  /* distance of matched string */\n  //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n\n    s.pending_buf[s.sym_buf + s.sym_next++] = dist;\n    s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;\n    s.pending_buf[s.sym_buf + s.sym_next++] = lc;\n    if (dist === 0) {\n      /* lc is the unmatched char */\n      s.dyn_ltree[lc * 2]/*.Freq*/++;\n    } else {\n      s.matches++;\n      /* Here, lc is the match length - MIN_MATCH */\n      dist--;             /* dist = match distance - 1 */\n      //Assert((ush)dist < (ush)MAX_DIST(s) &&\n      //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n      //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n      s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;\n      s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n    }\n\n    return (s.sym_next === s.sym_end);\n  };\n\n  var _tr_init_1  = _tr_init$1;\n  var _tr_stored_block_1 = _tr_stored_block$1;\n  var _tr_flush_block_1  = _tr_flush_block$1;\n  var _tr_tally_1 = _tr_tally$1;\n  var _tr_align_1 = _tr_align$1;\n\n  var trees = {\n  \t_tr_init: _tr_init_1,\n  \t_tr_stored_block: _tr_stored_block_1,\n  \t_tr_flush_block: _tr_flush_block_1,\n  \t_tr_tally: _tr_tally_1,\n  \t_tr_align: _tr_align_1\n  };\n\n  // Note: adler32 takes 12% for level 0 and 2% for level 6.\n  // It isn't worth it to make additional optimizations as in original.\n  // Small size is preferable.\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  const adler32 = (adler, buf, len, pos) => {\n    let s1 = (adler & 0xffff) |0,\n        s2 = ((adler >>> 16) & 0xffff) |0,\n        n = 0;\n\n    while (len !== 0) {\n      // Set limit ~ twice less than 5552, to keep\n      // s2 in 31-bits, because we force signed ints.\n      // in other case %= will fail.\n      n = len > 2000 ? 2000 : len;\n      len -= n;\n\n      do {\n        s1 = (s1 + buf[pos++]) |0;\n        s2 = (s2 + s1) |0;\n      } while (--n);\n\n      s1 %= 65521;\n      s2 %= 65521;\n    }\n\n    return (s1 | (s2 << 16)) |0;\n  };\n\n\n  var adler32_1 = adler32;\n\n  // Note: we can't get significant speed boost here.\n  // So write code to minimize size - no pregenerated tables\n  // and array tools dependencies.\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  // Use ordinary array, since untyped makes no boost here\n  const makeTable = () => {\n    let c, table = [];\n\n    for (var n = 0; n < 256; n++) {\n      c = n;\n      for (var k = 0; k < 8; k++) {\n        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n      }\n      table[n] = c;\n    }\n\n    return table;\n  };\n\n  // Create table on load. Just 255 signed longs. Not a problem.\n  const crcTable = new Uint32Array(makeTable());\n\n\n  const crc32 = (crc, buf, len, pos) => {\n    const t = crcTable;\n    const end = pos + len;\n\n    crc ^= -1;\n\n    for (let i = pos; i < end; i++) {\n      crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n    }\n\n    return (crc ^ (-1)); // >>> 0;\n  };\n\n\n  var crc32_1 = crc32;\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  var messages = {\n    2:      'need dictionary',     /* Z_NEED_DICT       2  */\n    1:      'stream end',          /* Z_STREAM_END      1  */\n    0:      '',                    /* Z_OK              0  */\n    '-1':   'file error',          /* Z_ERRNO         (-1) */\n    '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n    '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n    '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n    '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n    '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n  };\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  var constants$1 = {\n\n    /* Allowed flush values; see deflate() and inflate() below for details */\n    Z_NO_FLUSH:         0,\n    Z_PARTIAL_FLUSH:    1,\n    Z_SYNC_FLUSH:       2,\n    Z_FULL_FLUSH:       3,\n    Z_FINISH:           4,\n    Z_BLOCK:            5,\n    Z_TREES:            6,\n\n    /* Return codes for the compression/decompression functions. Negative values\n    * are errors, positive values are used for special but normal events.\n    */\n    Z_OK:               0,\n    Z_STREAM_END:       1,\n    Z_NEED_DICT:        2,\n    Z_ERRNO:           -1,\n    Z_STREAM_ERROR:    -2,\n    Z_DATA_ERROR:      -3,\n    Z_MEM_ERROR:       -4,\n    Z_BUF_ERROR:       -5,\n    //Z_VERSION_ERROR: -6,\n\n    /* compression levels */\n    Z_NO_COMPRESSION:         0,\n    Z_BEST_SPEED:             1,\n    Z_BEST_COMPRESSION:       9,\n    Z_DEFAULT_COMPRESSION:   -1,\n\n\n    Z_FILTERED:               1,\n    Z_HUFFMAN_ONLY:           2,\n    Z_RLE:                    3,\n    Z_FIXED:                  4,\n    Z_DEFAULT_STRATEGY:       0,\n\n    /* Possible values of the data_type field (though see inflate()) */\n    Z_BINARY:                 0,\n    Z_TEXT:                   1,\n    //Z_ASCII:                1, // = Z_TEXT (deprecated)\n    Z_UNKNOWN:                2,\n\n    /* The deflate compression method */\n    Z_DEFLATED:               8\n    //Z_NULL:                 null // Use -1 or null inline, depending on var type\n  };\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;\n\n\n\n\n  /* Public constants ==========================================================*/\n  /* ===========================================================================*/\n\n  const {\n    Z_NO_FLUSH: Z_NO_FLUSH$1, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$1, Z_BLOCK,\n    Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_STREAM_ERROR, Z_DATA_ERROR, Z_BUF_ERROR,\n    Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,\n    Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,\n    Z_UNKNOWN,\n    Z_DEFLATED: Z_DEFLATED$1\n  } = constants$1;\n\n  /*============================================================================*/\n\n\n  const MAX_MEM_LEVEL = 9;\n  /* Maximum value for memLevel in deflateInit2 */\n  const MAX_WBITS = 15;\n  /* 32K LZ77 window */\n  const DEF_MEM_LEVEL = 8;\n\n\n  const LENGTH_CODES  = 29;\n  /* number of length codes, not counting the special END_BLOCK code */\n  const LITERALS      = 256;\n  /* number of literal bytes 0..255 */\n  const L_CODES       = LITERALS + 1 + LENGTH_CODES;\n  /* number of Literal or Length codes, including the END_BLOCK code */\n  const D_CODES       = 30;\n  /* number of distance codes */\n  const BL_CODES      = 19;\n  /* number of codes used to transfer the bit lengths */\n  const HEAP_SIZE     = 2 * L_CODES + 1;\n  /* maximum heap size */\n  const MAX_BITS  = 15;\n  /* All codes must not exceed MAX_BITS bits */\n\n  const MIN_MATCH = 3;\n  const MAX_MATCH = 258;\n  const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\n  const PRESET_DICT = 0x20;\n\n  const INIT_STATE    =  42;    /* zlib header -> BUSY_STATE */\n  //#ifdef GZIP\n  const GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */\n  //#endif\n  const EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */\n  const NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */\n  const COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */\n  const HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */\n  const BUSY_STATE    = 113;    /* deflate -> FINISH_STATE */\n  const FINISH_STATE  = 666;    /* stream complete */\n\n  const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\n  const BS_BLOCK_DONE     = 2; /* block flush performed */\n  const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\n  const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\n  const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\n  const err = (strm, errorCode) => {\n    strm.msg = messages[errorCode];\n    return errorCode;\n  };\n\n  const rank = (f) => {\n    return ((f) * 2) - ((f) > 4 ? 9 : 0);\n  };\n\n  const zero = (buf) => {\n    let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n  };\n\n  /* ===========================================================================\n   * Slide the hash table when sliding the window down (could be avoided with 32\n   * bit values at the expense of memory usage). We slide even when level == 0 to\n   * keep the hash table consistent if we switch back to level > 0 later.\n   */\n  const slide_hash = (s) => {\n    let n, m;\n    let p;\n    let wsize = s.w_size;\n\n    n = s.hash_size;\n    p = n;\n    do {\n      m = s.head[--p];\n      s.head[p] = (m >= wsize ? m - wsize : 0);\n    } while (--n);\n    n = wsize;\n  //#ifndef FASTEST\n    p = n;\n    do {\n      m = s.prev[--p];\n      s.prev[p] = (m >= wsize ? m - wsize : 0);\n      /* If n is not on any hash chain, prev[n] is garbage but\n       * its value will never be used.\n       */\n    } while (--n);\n  //#endif\n  };\n\n  /* eslint-disable new-cap */\n  let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n  // This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n  // But breaks binary compatibility\n  //let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\n  let HASH = HASH_ZLIB;\n\n\n  /* =========================================================================\n   * Flush as much pending output as possible. All deflate() output, except for\n   * some deflate_stored() output, goes through this function so some\n   * applications may wish to modify it to avoid allocating a large\n   * strm->next_out buffer and copying into it. (See also read_buf()).\n   */\n  const flush_pending = (strm) => {\n    const s = strm.state;\n\n    //_tr_flush_bits(s);\n    let len = s.pending;\n    if (len > strm.avail_out) {\n      len = strm.avail_out;\n    }\n    if (len === 0) { return; }\n\n    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n    strm.next_out  += len;\n    s.pending_out  += len;\n    strm.total_out += len;\n    strm.avail_out -= len;\n    s.pending      -= len;\n    if (s.pending === 0) {\n      s.pending_out = 0;\n    }\n  };\n\n\n  const flush_block_only = (s, last) => {\n    _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n    s.block_start = s.strstart;\n    flush_pending(s.strm);\n  };\n\n\n  const put_byte = (s, b) => {\n    s.pending_buf[s.pending++] = b;\n  };\n\n\n  /* =========================================================================\n   * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n   * IN assertion: the stream state is correct and there is enough room in\n   * pending_buf.\n   */\n  const putShortMSB = (s, b) => {\n\n    //  put_byte(s, (Byte)(b >> 8));\n  //  put_byte(s, (Byte)(b & 0xff));\n    s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n    s.pending_buf[s.pending++] = b & 0xff;\n  };\n\n\n  /* ===========================================================================\n   * Read a new buffer from the current input stream, update the adler32\n   * and total number of bytes read.  All deflate() input goes through\n   * this function so some applications may wish to modify it to avoid\n   * allocating a large strm->input buffer and copying from it.\n   * (See also flush_pending()).\n   */\n  const read_buf = (strm, buf, start, size) => {\n\n    let len = strm.avail_in;\n\n    if (len > size) { len = size; }\n    if (len === 0) { return 0; }\n\n    strm.avail_in -= len;\n\n    // zmemcpy(buf, strm->next_in, len);\n    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n    if (strm.state.wrap === 1) {\n      strm.adler = adler32_1(strm.adler, buf, len, start);\n    }\n\n    else if (strm.state.wrap === 2) {\n      strm.adler = crc32_1(strm.adler, buf, len, start);\n    }\n\n    strm.next_in += len;\n    strm.total_in += len;\n\n    return len;\n  };\n\n\n  /* ===========================================================================\n   * Set match_start to the longest match starting at the given string and\n   * return its length. Matches shorter or equal to prev_length are discarded,\n   * in which case the result is equal to prev_length and match_start is\n   * garbage.\n   * IN assertions: cur_match is the head of the hash chain for the current\n   *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n   * OUT assertion: the match length is not greater than s->lookahead.\n   */\n  const longest_match = (s, cur_match) => {\n\n    let chain_length = s.max_chain_length;      /* max hash chain length */\n    let scan = s.strstart; /* current string */\n    let match;                       /* matched string */\n    let len;                           /* length of current match */\n    let best_len = s.prev_length;              /* best match length so far */\n    let nice_match = s.nice_match;             /* stop if match long enough */\n    const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n        s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n    const _win = s.window; // shortcut\n\n    const wmask = s.w_mask;\n    const prev  = s.prev;\n\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n     * we prevent matches with the string of window index 0.\n     */\n\n    const strend = s.strstart + MAX_MATCH;\n    let scan_end1  = _win[scan + best_len - 1];\n    let scan_end   = _win[scan + best_len];\n\n    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n     * It is easy to get rid of this optimization if necessary.\n     */\n    // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n    /* Do not waste too much time if we already have a good match: */\n    if (s.prev_length >= s.good_match) {\n      chain_length >>= 2;\n    }\n    /* Do not look for matches beyond the end of the input. This is necessary\n     * to make deflate deterministic.\n     */\n    if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n    // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n    do {\n      // Assert(cur_match < s->strstart, \"no future\");\n      match = cur_match;\n\n      /* Skip to next match if the match length cannot increase\n       * or if the match length is less than 2.  Note that the checks below\n       * for insufficient lookahead only occur occasionally for performance\n       * reasons.  Therefore uninitialized memory will be accessed, and\n       * conditional jumps will be made that depend on those values.\n       * However the length of the match is limited to the lookahead, so\n       * the output of deflate is not affected by the uninitialized values.\n       */\n\n      if (_win[match + best_len]     !== scan_end  ||\n          _win[match + best_len - 1] !== scan_end1 ||\n          _win[match]                !== _win[scan] ||\n          _win[++match]              !== _win[scan + 1]) {\n        continue;\n      }\n\n      /* The check at best_len-1 can be removed because it will be made\n       * again later. (This heuristic is not always a win.)\n       * It is not necessary to compare scan[2] and match[2] since they\n       * are always equal when the other bytes match, given that\n       * the hash keys are equal and that HASH_BITS >= 8.\n       */\n      scan += 2;\n      match++;\n      // Assert(*scan == *match, \"match[2]?\");\n\n      /* We check for insufficient lookahead only every 8th comparison;\n       * the 256th check will be made at strstart+258.\n       */\n      do {\n        /*jshint noempty:false*/\n      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n               _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n               _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n               _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n               scan < strend);\n\n      // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n      len = MAX_MATCH - (strend - scan);\n      scan = strend - MAX_MATCH;\n\n      if (len > best_len) {\n        s.match_start = cur_match;\n        best_len = len;\n        if (len >= nice_match) {\n          break;\n        }\n        scan_end1  = _win[scan + best_len - 1];\n        scan_end   = _win[scan + best_len];\n      }\n    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n    if (best_len <= s.lookahead) {\n      return best_len;\n    }\n    return s.lookahead;\n  };\n\n\n  /* ===========================================================================\n   * Fill the window when the lookahead becomes insufficient.\n   * Updates strstart and lookahead.\n   *\n   * IN assertion: lookahead < MIN_LOOKAHEAD\n   * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n   *    At least one byte has been read, or avail_in == 0; reads are\n   *    performed for at least two bytes (required for the zip translate_eol\n   *    option -- not supported here).\n   */\n  const fill_window = (s) => {\n\n    const _w_size = s.w_size;\n    let n, more, str;\n\n    //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n    do {\n      more = s.window_size - s.lookahead - s.strstart;\n\n      // JS ints have 32 bit, block below not needed\n      /* Deal with !@#$% 64K limit: */\n      //if (sizeof(int) <= 2) {\n      //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n      //        more = wsize;\n      //\n      //  } else if (more == (unsigned)(-1)) {\n      //        /* Very unlikely, but possible on 16 bit machine if\n      //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n      //         */\n      //        more--;\n      //    }\n      //}\n\n\n      /* If the window is almost full and there is insufficient lookahead,\n       * move the upper half to the lower one to make room in the upper half.\n       */\n      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n        s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);\n        s.match_start -= _w_size;\n        s.strstart -= _w_size;\n        /* we now have strstart >= MAX_DIST */\n        s.block_start -= _w_size;\n        if (s.insert > s.strstart) {\n          s.insert = s.strstart;\n        }\n        slide_hash(s);\n        more += _w_size;\n      }\n      if (s.strm.avail_in === 0) {\n        break;\n      }\n\n      /* If there was no sliding:\n       *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n       *    more == window_size - lookahead - strstart\n       * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n       * => more >= window_size - 2*WSIZE + 2\n       * In the BIG_MEM or MMAP case (not yet supported),\n       *   window_size == input_size + MIN_LOOKAHEAD  &&\n       *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n       * Otherwise, window_size == 2*WSIZE so more >= 2.\n       * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n       */\n      //Assert(more >= 2, \"more < 2\");\n      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n      s.lookahead += n;\n\n      /* Initialize the hash value now that we have some input: */\n      if (s.lookahead + s.insert >= MIN_MATCH) {\n        str = s.strstart - s.insert;\n        s.ins_h = s.window[str];\n\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n  //#if MIN_MATCH != 3\n  //        Call update_hash() MIN_MATCH-3 more times\n  //#endif\n        while (s.insert) {\n          /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n          s.prev[str & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = str;\n          str++;\n          s.insert--;\n          if (s.lookahead + s.insert < MIN_MATCH) {\n            break;\n          }\n        }\n      }\n      /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n       * but this is not important since only literal bytes will be emitted.\n       */\n\n    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n    /* If the WIN_INIT bytes after the end of the current data have never been\n     * written, then zero those bytes in order to avoid memory check reports of\n     * the use of uninitialized (or uninitialised as Julian writes) bytes by\n     * the longest match routines.  Update the high water mark for the next\n     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n     */\n  //  if (s.high_water < s.window_size) {\n  //    const curr = s.strstart + s.lookahead;\n  //    let init = 0;\n  //\n  //    if (s.high_water < curr) {\n  //      /* Previous high water mark below current data -- zero WIN_INIT\n  //       * bytes or up to end of window, whichever is less.\n  //       */\n  //      init = s.window_size - curr;\n  //      if (init > WIN_INIT)\n  //        init = WIN_INIT;\n  //      zmemzero(s->window + curr, (unsigned)init);\n  //      s->high_water = curr + init;\n  //    }\n  //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n  //      /* High water mark at or above current data, but below current data\n  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n  //       * to end of window, whichever is less.\n  //       */\n  //      init = (ulg)curr + WIN_INIT - s->high_water;\n  //      if (init > s->window_size - s->high_water)\n  //        init = s->window_size - s->high_water;\n  //      zmemzero(s->window + s->high_water, (unsigned)init);\n  //      s->high_water += init;\n  //    }\n  //  }\n  //\n  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n  //    \"not enough room for search\");\n  };\n\n  /* ===========================================================================\n   * Copy without compression as much as possible from the input stream, return\n   * the current block state.\n   *\n   * In case deflateParams() is used to later switch to a non-zero compression\n   * level, s->matches (otherwise unused when storing) keeps track of the number\n   * of hash table slides to perform. If s->matches is 1, then one hash table\n   * slide will be done when switching. If s->matches is 2, the maximum value\n   * allowed here, then the hash table will be cleared, since two or more slides\n   * is the same as a clear.\n   *\n   * deflate_stored() is written to minimize the number of times an input byte is\n   * copied. It is most efficient with large input and output buffers, which\n   * maximizes the opportunites to have a single copy from next_in to next_out.\n   */\n  const deflate_stored = (s, flush) => {\n\n    /* Smallest worthy block size when not flushing or finishing. By default\n     * this is 32K. This can be as small as 507 bytes for memLevel == 1. For\n     * large input and output buffers, the stored block size will be larger.\n     */\n    let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;\n\n    /* Copy as many min_block or larger stored blocks directly to next_out as\n     * possible. If flushing, copy the remaining available input to next_out as\n     * stored blocks, if there is enough space.\n     */\n    let len, left, have, last = 0;\n    let used = s.strm.avail_in;\n    do {\n      /* Set len to the maximum size block that we can copy directly with the\n       * available input data and output space. Set left to how much of that\n       * would be copied from what's left in the window.\n       */\n      len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */\n      have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n      if (s.strm.avail_out < have) {         /* need room for header */\n        break;\n      }\n        /* maximum stored block length that will fit in avail_out: */\n      have = s.strm.avail_out - have;\n      left = s.strstart - s.block_start;  /* bytes left in window */\n      if (len > left + s.strm.avail_in) {\n        len = left + s.strm.avail_in;   /* limit len to the input */\n      }\n      if (len > have) {\n        len = have;             /* limit len to the output */\n      }\n\n      /* If the stored block would be less than min_block in length, or if\n       * unable to copy all of the available input when flushing, then try\n       * copying to the window and the pending buffer instead. Also don't\n       * write an empty block when flushing -- deflate() does that.\n       */\n      if (len < min_block && ((len === 0 && flush !== Z_FINISH$1) ||\n                          flush === Z_NO_FLUSH$1 ||\n                          len !== left + s.strm.avail_in)) {\n        break;\n      }\n\n      /* Make a dummy stored block in pending to get the header bytes,\n       * including any pending bits. This also updates the debugging counts.\n       */\n      last = flush === Z_FINISH$1 && len === left + s.strm.avail_in ? 1 : 0;\n      _tr_stored_block(s, 0, 0, last);\n\n      /* Replace the lengths in the dummy stored block with len. */\n      s.pending_buf[s.pending - 4] = len;\n      s.pending_buf[s.pending - 3] = len >> 8;\n      s.pending_buf[s.pending - 2] = ~len;\n      s.pending_buf[s.pending - 1] = ~len >> 8;\n\n      /* Write the stored block header bytes. */\n      flush_pending(s.strm);\n\n  //#ifdef ZLIB_DEBUG\n  //    /* Update debugging counts for the data about to be copied. */\n  //    s->compressed_len += len << 3;\n  //    s->bits_sent += len << 3;\n  //#endif\n\n      /* Copy uncompressed bytes from the window to next_out. */\n      if (left) {\n        if (left > len) {\n          left = len;\n        }\n        //zmemcpy(s->strm->next_out, s->window + s->block_start, left);\n        s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);\n        s.strm.next_out += left;\n        s.strm.avail_out -= left;\n        s.strm.total_out += left;\n        s.block_start += left;\n        len -= left;\n      }\n\n      /* Copy uncompressed bytes directly from next_in to next_out, updating\n       * the check value.\n       */\n      if (len) {\n        read_buf(s.strm, s.strm.output, s.strm.next_out, len);\n        s.strm.next_out += len;\n        s.strm.avail_out -= len;\n        s.strm.total_out += len;\n      }\n    } while (last === 0);\n\n    /* Update the sliding window with the last s->w_size bytes of the copied\n     * data, or append all of the copied data to the existing window if less\n     * than s->w_size bytes were copied. Also update the number of bytes to\n     * insert in the hash tables, in the event that deflateParams() switches to\n     * a non-zero compression level.\n     */\n    used -= s.strm.avail_in;    /* number of input bytes directly copied */\n    if (used) {\n      /* If any input was used, then no unused input remains in the window,\n       * therefore s->block_start == s->strstart.\n       */\n      if (used >= s.w_size) {  /* supplant the previous history */\n        s.matches = 2;     /* clear hash */\n        //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);\n        s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);\n        s.strstart = s.w_size;\n        s.insert = s.strstart;\n      }\n      else {\n        if (s.window_size - s.strstart <= used) {\n          /* Slide the window down. */\n          s.strstart -= s.w_size;\n          //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n          s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n          if (s.matches < 2) {\n            s.matches++;   /* add a pending slide_hash() */\n          }\n          if (s.insert > s.strstart) {\n            s.insert = s.strstart;\n          }\n        }\n        //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);\n        s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);\n        s.strstart += used;\n        s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;\n      }\n      s.block_start = s.strstart;\n    }\n    if (s.high_water < s.strstart) {\n      s.high_water = s.strstart;\n    }\n\n    /* If the last block was written to next_out, then done. */\n    if (last) {\n      return BS_FINISH_DONE;\n    }\n\n    /* If flushing and all input has been consumed, then done. */\n    if (flush !== Z_NO_FLUSH$1 && flush !== Z_FINISH$1 &&\n      s.strm.avail_in === 0 && s.strstart === s.block_start) {\n      return BS_BLOCK_DONE;\n    }\n\n    /* Fill the window with any remaining input. */\n    have = s.window_size - s.strstart;\n    if (s.strm.avail_in > have && s.block_start >= s.w_size) {\n      /* Slide the window down. */\n      s.block_start -= s.w_size;\n      s.strstart -= s.w_size;\n      //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n      s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n      if (s.matches < 2) {\n        s.matches++;       /* add a pending slide_hash() */\n      }\n      have += s.w_size;      /* more space now */\n      if (s.insert > s.strstart) {\n        s.insert = s.strstart;\n      }\n    }\n    if (have > s.strm.avail_in) {\n      have = s.strm.avail_in;\n    }\n    if (have) {\n      read_buf(s.strm, s.window, s.strstart, have);\n      s.strstart += have;\n      s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;\n    }\n    if (s.high_water < s.strstart) {\n      s.high_water = s.strstart;\n    }\n\n    /* There was not enough avail_out to write a complete worthy or flushed\n     * stored block to next_out. Write a stored block to pending instead, if we\n     * have enough input for a worthy block, or if flushing and there is enough\n     * room for the remaining input as a stored block in the pending buffer.\n     */\n    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n      /* maximum stored block length that will fit in pending: */\n    have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;\n    min_block = have > s.w_size ? s.w_size : have;\n    left = s.strstart - s.block_start;\n    if (left >= min_block ||\n       ((left || flush === Z_FINISH$1) && flush !== Z_NO_FLUSH$1 &&\n       s.strm.avail_in === 0 && left <= have)) {\n      len = left > have ? have : left;\n      last = flush === Z_FINISH$1 && s.strm.avail_in === 0 &&\n           len === left ? 1 : 0;\n      _tr_stored_block(s, s.block_start, len, last);\n      s.block_start += len;\n      flush_pending(s.strm);\n    }\n\n    /* We've done all we can with the available input and output. */\n    return last ? BS_FINISH_STARTED : BS_NEED_MORE;\n  };\n\n\n  /* ===========================================================================\n   * Compress as much as possible from the input stream, return the current\n   * block state.\n   * This function does not perform lazy evaluation of matches and inserts\n   * new strings in the dictionary only for unmatched strings or for short\n   * matches. It is used only for the fast compression options.\n   */\n  const deflate_fast = (s, flush) => {\n\n    let hash_head;        /* head of the hash chain */\n    let bflush;           /* set if current block must be flushed */\n\n    for (;;) {\n      /* Make sure that we always have enough lookahead, except\n       * at the end of the input file. We need MAX_MATCH bytes\n       * for the next match, plus MIN_MATCH bytes to insert the\n       * string following the next match.\n       */\n      if (s.lookahead < MIN_LOOKAHEAD) {\n        fill_window(s);\n        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {\n          return BS_NEED_MORE;\n        }\n        if (s.lookahead === 0) {\n          break; /* flush the current block */\n        }\n      }\n\n      /* Insert the string window[strstart .. strstart+2] in the\n       * dictionary, and set hash_head to the head of the hash chain:\n       */\n      hash_head = 0/*NIL*/;\n      if (s.lookahead >= MIN_MATCH) {\n        /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = s.strstart;\n        /***/\n      }\n\n      /* Find the longest match, discarding those <= prev_length.\n       * At this point we have always match_length < MIN_MATCH\n       */\n      if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n        /* To simplify the code, we prevent matches with the string\n         * of window index 0 (in particular we have to avoid a match\n         * of the string with itself at the start of the input file).\n         */\n        s.match_length = longest_match(s, hash_head);\n        /* longest_match() sets match_start */\n      }\n      if (s.match_length >= MIN_MATCH) {\n        // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n        /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                       s.match_length - MIN_MATCH, bflush); ***/\n        bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n        s.lookahead -= s.match_length;\n\n        /* Insert new strings in the hash table only if the match length\n         * is not too large. This saves time but degrades compression.\n         */\n        if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n          s.match_length--; /* string at strstart already in table */\n          do {\n            s.strstart++;\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n            /***/\n            /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n             * always MIN_MATCH bytes ahead.\n             */\n          } while (--s.match_length !== 0);\n          s.strstart++;\n        } else\n        {\n          s.strstart += s.match_length;\n          s.match_length = 0;\n          s.ins_h = s.window[s.strstart];\n          /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n\n  //#if MIN_MATCH != 3\n  //                Call UPDATE_HASH() MIN_MATCH-3 more times\n  //#endif\n          /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n           * matter since it will be recomputed at next deflate call.\n           */\n        }\n      } else {\n        /* No match, output a literal byte */\n        //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n        bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n        s.lookahead--;\n        s.strstart++;\n      }\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n    }\n    s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n    if (flush === Z_FINISH$1) {\n      /*** FLUSH_BLOCK(s, 1); ***/\n      flush_block_only(s, true);\n      if (s.strm.avail_out === 0) {\n        return BS_FINISH_STARTED;\n      }\n      /***/\n      return BS_FINISH_DONE;\n    }\n    if (s.sym_next) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n    return BS_BLOCK_DONE;\n  };\n\n  /* ===========================================================================\n   * Same as above, but achieves better compression. We use a lazy\n   * evaluation for matches: a match is finally adopted only if there is\n   * no better match at the next window position.\n   */\n  const deflate_slow = (s, flush) => {\n\n    let hash_head;          /* head of hash chain */\n    let bflush;              /* set if current block must be flushed */\n\n    let max_insert;\n\n    /* Process the input block. */\n    for (;;) {\n      /* Make sure that we always have enough lookahead, except\n       * at the end of the input file. We need MAX_MATCH bytes\n       * for the next match, plus MIN_MATCH bytes to insert the\n       * string following the next match.\n       */\n      if (s.lookahead < MIN_LOOKAHEAD) {\n        fill_window(s);\n        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$1) {\n          return BS_NEED_MORE;\n        }\n        if (s.lookahead === 0) { break; } /* flush the current block */\n      }\n\n      /* Insert the string window[strstart .. strstart+2] in the\n       * dictionary, and set hash_head to the head of the hash chain:\n       */\n      hash_head = 0/*NIL*/;\n      if (s.lookahead >= MIN_MATCH) {\n        /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = s.strstart;\n        /***/\n      }\n\n      /* Find the longest match, discarding those <= prev_length.\n       */\n      s.prev_length = s.match_length;\n      s.prev_match = s.match_start;\n      s.match_length = MIN_MATCH - 1;\n\n      if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n          s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n        /* To simplify the code, we prevent matches with the string\n         * of window index 0 (in particular we have to avoid a match\n         * of the string with itself at the start of the input file).\n         */\n        s.match_length = longest_match(s, hash_head);\n        /* longest_match() sets match_start */\n\n        if (s.match_length <= 5 &&\n           (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n          /* If prev_match is also MIN_MATCH, match_start is garbage\n           * but we will ignore the current match anyway.\n           */\n          s.match_length = MIN_MATCH - 1;\n        }\n      }\n      /* If there was a match at the previous step and the current\n       * match is not better, output the previous match:\n       */\n      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n        max_insert = s.strstart + s.lookahead - MIN_MATCH;\n        /* Do not insert strings in hash table beyond this. */\n\n        //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n        /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                       s.prev_length - MIN_MATCH, bflush);***/\n        bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n        /* Insert in hash table all strings up to the end of the match.\n         * strstart-1 and strstart are already inserted. If there is not\n         * enough lookahead, the last two strings are not inserted in\n         * the hash table.\n         */\n        s.lookahead -= s.prev_length - 1;\n        s.prev_length -= 2;\n        do {\n          if (++s.strstart <= max_insert) {\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n            /***/\n          }\n        } while (--s.prev_length !== 0);\n        s.match_available = 0;\n        s.match_length = MIN_MATCH - 1;\n        s.strstart++;\n\n        if (bflush) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n        }\n\n      } else if (s.match_available) {\n        /* If there was no match at the previous position, output a\n         * single literal. If there was a match but the current match\n         * is longer, truncate the previous match to a single literal.\n         */\n        //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n        /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n        if (bflush) {\n          /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n          flush_block_only(s, false);\n          /***/\n        }\n        s.strstart++;\n        s.lookahead--;\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      } else {\n        /* There is no previous match to compare with, wait for\n         * the next step to decide.\n         */\n        s.match_available = 1;\n        s.strstart++;\n        s.lookahead--;\n      }\n    }\n    //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n    if (s.match_available) {\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      s.match_available = 0;\n    }\n    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n    if (flush === Z_FINISH$1) {\n      /*** FLUSH_BLOCK(s, 1); ***/\n      flush_block_only(s, true);\n      if (s.strm.avail_out === 0) {\n        return BS_FINISH_STARTED;\n      }\n      /***/\n      return BS_FINISH_DONE;\n    }\n    if (s.sym_next) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n\n    return BS_BLOCK_DONE;\n  };\n\n\n  /* ===========================================================================\n   * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n   * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n   * deflate switches away from Z_RLE.)\n   */\n  const deflate_rle = (s, flush) => {\n\n    let bflush;            /* set if current block must be flushed */\n    let prev;              /* byte at distance one to match */\n    let scan, strend;      /* scan goes up to strend for length of run */\n\n    const _win = s.window;\n\n    for (;;) {\n      /* Make sure that we always have enough lookahead, except\n       * at the end of the input file. We need MAX_MATCH bytes\n       * for the longest run, plus one for the unrolled loop.\n       */\n      if (s.lookahead <= MAX_MATCH) {\n        fill_window(s);\n        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$1) {\n          return BS_NEED_MORE;\n        }\n        if (s.lookahead === 0) { break; } /* flush the current block */\n      }\n\n      /* See how many times the previous byte repeats */\n      s.match_length = 0;\n      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n        scan = s.strstart - 1;\n        prev = _win[scan];\n        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n          strend = s.strstart + MAX_MATCH;\n          do {\n            /*jshint noempty:false*/\n          } while (prev === _win[++scan] && prev === _win[++scan] &&\n                   prev === _win[++scan] && prev === _win[++scan] &&\n                   prev === _win[++scan] && prev === _win[++scan] &&\n                   prev === _win[++scan] && prev === _win[++scan] &&\n                   scan < strend);\n          s.match_length = MAX_MATCH - (strend - scan);\n          if (s.match_length > s.lookahead) {\n            s.match_length = s.lookahead;\n          }\n        }\n        //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n      }\n\n      /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n      if (s.match_length >= MIN_MATCH) {\n        //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n        /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n        bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n        s.lookahead -= s.match_length;\n        s.strstart += s.match_length;\n        s.match_length = 0;\n      } else {\n        /* No match, output a literal byte */\n        //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n        bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n        s.lookahead--;\n        s.strstart++;\n      }\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH$1) {\n      /*** FLUSH_BLOCK(s, 1); ***/\n      flush_block_only(s, true);\n      if (s.strm.avail_out === 0) {\n        return BS_FINISH_STARTED;\n      }\n      /***/\n      return BS_FINISH_DONE;\n    }\n    if (s.sym_next) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n    return BS_BLOCK_DONE;\n  };\n\n  /* ===========================================================================\n   * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n   * (It will be regenerated if this run of deflate switches away from Huffman.)\n   */\n  const deflate_huff = (s, flush) => {\n\n    let bflush;             /* set if current block must be flushed */\n\n    for (;;) {\n      /* Make sure that we have a literal to write. */\n      if (s.lookahead === 0) {\n        fill_window(s);\n        if (s.lookahead === 0) {\n          if (flush === Z_NO_FLUSH$1) {\n            return BS_NEED_MORE;\n          }\n          break;      /* flush the current block */\n        }\n      }\n\n      /* Output a literal byte */\n      s.match_length = 0;\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n      s.lookahead--;\n      s.strstart++;\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH$1) {\n      /*** FLUSH_BLOCK(s, 1); ***/\n      flush_block_only(s, true);\n      if (s.strm.avail_out === 0) {\n        return BS_FINISH_STARTED;\n      }\n      /***/\n      return BS_FINISH_DONE;\n    }\n    if (s.sym_next) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n    return BS_BLOCK_DONE;\n  };\n\n  /* Values for max_lazy_match, good_match and max_chain_length, depending on\n   * the desired pack level (0..9). The values given below have been tuned to\n   * exclude worst case performance for pathological files. Better values may be\n   * found for specific files.\n   */\n  function Config(good_length, max_lazy, nice_length, max_chain, func) {\n\n    this.good_length = good_length;\n    this.max_lazy = max_lazy;\n    this.nice_length = nice_length;\n    this.max_chain = max_chain;\n    this.func = func;\n  }\n\n  const configuration_table = [\n    /*      good lazy nice chain */\n    new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n    new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n    new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n    new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n    new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n    new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n    new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n    new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n    new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n    new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n  ];\n\n\n  /* ===========================================================================\n   * Initialize the \"longest match\" routines for a new zlib stream\n   */\n  const lm_init = (s) => {\n\n    s.window_size = 2 * s.w_size;\n\n    /*** CLEAR_HASH(s); ***/\n    zero(s.head); // Fill with NIL (= 0);\n\n    /* Set the default configuration parameters:\n     */\n    s.max_lazy_match = configuration_table[s.level].max_lazy;\n    s.good_match = configuration_table[s.level].good_length;\n    s.nice_match = configuration_table[s.level].nice_length;\n    s.max_chain_length = configuration_table[s.level].max_chain;\n\n    s.strstart = 0;\n    s.block_start = 0;\n    s.lookahead = 0;\n    s.insert = 0;\n    s.match_length = s.prev_length = MIN_MATCH - 1;\n    s.match_available = 0;\n    s.ins_h = 0;\n  };\n\n\n  function DeflateState() {\n    this.strm = null;            /* pointer back to this zlib stream */\n    this.status = 0;            /* as the name implies */\n    this.pending_buf = null;      /* output still pending */\n    this.pending_buf_size = 0;  /* size of pending_buf */\n    this.pending_out = 0;       /* next pending byte to output to the stream */\n    this.pending = 0;           /* nb of bytes in the pending buffer */\n    this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n    this.gzhead = null;         /* gzip header information to write */\n    this.gzindex = 0;           /* where in extra, name, or comment */\n    this.method = Z_DEFLATED$1; /* can only be DEFLATED */\n    this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n    this.w_size = 0;  /* LZ77 window size (32K by default) */\n    this.w_bits = 0;  /* log2(w_size)  (8..16) */\n    this.w_mask = 0;  /* w_size - 1 */\n\n    this.window = null;\n    /* Sliding window. Input bytes are read into the second half of the window,\n     * and move to the first half later to keep a dictionary of at least wSize\n     * bytes. With this organization, matches are limited to a distance of\n     * wSize-MAX_MATCH bytes, but this ensures that IO is always\n     * performed with a length multiple of the block size.\n     */\n\n    this.window_size = 0;\n    /* Actual size of window: 2*wSize, except when the user input buffer\n     * is directly used as sliding window.\n     */\n\n    this.prev = null;\n    /* Link to older string with same hash index. To limit the size of this\n     * array to 64K, this link is maintained only for the last 32K strings.\n     * An index in this array is thus a window index modulo 32K.\n     */\n\n    this.head = null;   /* Heads of the hash chains or NIL. */\n\n    this.ins_h = 0;       /* hash index of string to be inserted */\n    this.hash_size = 0;   /* number of elements in hash table */\n    this.hash_bits = 0;   /* log2(hash_size) */\n    this.hash_mask = 0;   /* hash_size-1 */\n\n    this.hash_shift = 0;\n    /* Number of bits by which ins_h must be shifted at each input\n     * step. It must be such that after MIN_MATCH steps, the oldest\n     * byte no longer takes part in the hash key, that is:\n     *   hash_shift * MIN_MATCH >= hash_bits\n     */\n\n    this.block_start = 0;\n    /* Window position at the beginning of the current output block. Gets\n     * negative when the window is moved backwards.\n     */\n\n    this.match_length = 0;      /* length of best match */\n    this.prev_match = 0;        /* previous match */\n    this.match_available = 0;   /* set if previous match exists */\n    this.strstart = 0;          /* start of string to insert */\n    this.match_start = 0;       /* start of matching string */\n    this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n    this.prev_length = 0;\n    /* Length of the best match at previous step. Matches not greater than this\n     * are discarded. This is used in the lazy match evaluation.\n     */\n\n    this.max_chain_length = 0;\n    /* To speed up deflation, hash chains are never searched beyond this\n     * length.  A higher limit improves compression ratio but degrades the\n     * speed.\n     */\n\n    this.max_lazy_match = 0;\n    /* Attempt to find a better match only when the current match is strictly\n     * smaller than this value. This mechanism is used only for compression\n     * levels >= 4.\n     */\n    // That's alias to max_lazy_match, don't use directly\n    //this.max_insert_length = 0;\n    /* Insert new strings in the hash table only if the match length is not\n     * greater than this length. This saves time but degrades compression.\n     * max_insert_length is used only for compression levels <= 3.\n     */\n\n    this.level = 0;     /* compression level (1..9) */\n    this.strategy = 0;  /* favor or force Huffman coding*/\n\n    this.good_match = 0;\n    /* Use a faster search when the previous match is longer than this */\n\n    this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n                /* used by trees.c: */\n\n    /* Didn't use ct_data typedef below to suppress compiler warning */\n\n    // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n    // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n    // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n    // Use flat array of DOUBLE size, with interleaved fata,\n    // because JS does not support effective\n    this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);\n    this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);\n    this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);\n    zero(this.dyn_ltree);\n    zero(this.dyn_dtree);\n    zero(this.bl_tree);\n\n    this.l_desc   = null;         /* desc. for literal tree */\n    this.d_desc   = null;         /* desc. for distance tree */\n    this.bl_desc  = null;         /* desc. for bit length tree */\n\n    //ush bl_count[MAX_BITS+1];\n    this.bl_count = new Uint16Array(MAX_BITS + 1);\n    /* number of codes at each bit length for an optimal tree */\n\n    //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n    this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n    zero(this.heap);\n\n    this.heap_len = 0;               /* number of elements in the heap */\n    this.heap_max = 0;               /* element of largest frequency */\n    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n     * The same heap array is used to build all trees.\n     */\n\n    this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n    zero(this.depth);\n    /* Depth of each subtree used as tie breaker for trees of equal frequency\n     */\n\n    this.sym_buf = 0;        /* buffer for distances and literals/lengths */\n\n    this.lit_bufsize = 0;\n    /* Size of match buffer for literals/lengths.  There are 4 reasons for\n     * limiting lit_bufsize to 64K:\n     *   - frequencies can be kept in 16 bit counters\n     *   - if compression is not successful for the first block, all input\n     *     data is still in the window so we can still emit a stored block even\n     *     when input comes from standard input.  (This can also be done for\n     *     all blocks if lit_bufsize is not greater than 32K.)\n     *   - if compression is not successful for a file smaller than 64K, we can\n     *     even emit a stored file instead of a stored block (saving 5 bytes).\n     *     This is applicable only for zip (not gzip or zlib).\n     *   - creating new Huffman trees less frequently may not provide fast\n     *     adaptation to changes in the input data statistics. (Take for\n     *     example a binary file with poorly compressible code followed by\n     *     a highly compressible string table.) Smaller buffer sizes give\n     *     fast adaptation but have of course the overhead of transmitting\n     *     trees more frequently.\n     *   - I can't count above 4\n     */\n\n    this.sym_next = 0;      /* running index in sym_buf */\n    this.sym_end = 0;       /* symbol table full when sym_next reaches this */\n\n    this.opt_len = 0;       /* bit length of current block with optimal trees */\n    this.static_len = 0;    /* bit length of current block with static trees */\n    this.matches = 0;       /* number of string matches in current block */\n    this.insert = 0;        /* bytes at end of window left to insert */\n\n\n    this.bi_buf = 0;\n    /* Output buffer. bits are inserted starting at the bottom (least\n     * significant bits).\n     */\n    this.bi_valid = 0;\n    /* Number of valid bits in bi_buf.  All bits above the last valid bit\n     * are always zero.\n     */\n\n    // Used for window memory init. We safely ignore it for JS. That makes\n    // sense only for pointers and memory check tools.\n    //this.high_water = 0;\n    /* High water mark offset in window for initialized bytes -- bytes above\n     * this are set to zero in order to avoid memory check warnings when\n     * longest match routines access bytes past the input.  This is then\n     * updated to the new high water mark.\n     */\n  }\n\n\n  /* =========================================================================\n   * Check for a valid deflate stream state. Return 0 if ok, 1 if not.\n   */\n  const deflateStateCheck = (strm) => {\n\n    if (!strm) {\n      return 1;\n    }\n    const s = strm.state;\n    if (!s || s.strm !== strm || (s.status !== INIT_STATE &&\n  //#ifdef GZIP\n                                  s.status !== GZIP_STATE &&\n  //#endif\n                                  s.status !== EXTRA_STATE &&\n                                  s.status !== NAME_STATE &&\n                                  s.status !== COMMENT_STATE &&\n                                  s.status !== HCRC_STATE &&\n                                  s.status !== BUSY_STATE &&\n                                  s.status !== FINISH_STATE)) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  const deflateResetKeep = (strm) => {\n\n    if (deflateStateCheck(strm)) {\n      return err(strm, Z_STREAM_ERROR);\n    }\n\n    strm.total_in = strm.total_out = 0;\n    strm.data_type = Z_UNKNOWN;\n\n    const s = strm.state;\n    s.pending = 0;\n    s.pending_out = 0;\n\n    if (s.wrap < 0) {\n      s.wrap = -s.wrap;\n      /* was made negative by deflate(..., Z_FINISH); */\n    }\n    s.status =\n  //#ifdef GZIP\n      s.wrap === 2 ? GZIP_STATE :\n  //#endif\n      s.wrap ? INIT_STATE : BUSY_STATE;\n    strm.adler = (s.wrap === 2) ?\n      0  // crc32(0, Z_NULL, 0)\n    :\n      1; // adler32(0, Z_NULL, 0)\n    s.last_flush = -2;\n    _tr_init(s);\n    return Z_OK$1;\n  };\n\n\n  const deflateReset = (strm) => {\n\n    const ret = deflateResetKeep(strm);\n    if (ret === Z_OK$1) {\n      lm_init(strm.state);\n    }\n    return ret;\n  };\n\n\n  const deflateSetHeader = (strm, head) => {\n\n    if (deflateStateCheck(strm) || strm.state.wrap !== 2) {\n      return Z_STREAM_ERROR;\n    }\n    strm.state.gzhead = head;\n    return Z_OK$1;\n  };\n\n\n  const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n\n    if (!strm) { // === Z_NULL\n      return Z_STREAM_ERROR;\n    }\n    let wrap = 1;\n\n    if (level === Z_DEFAULT_COMPRESSION$1) {\n      level = 6;\n    }\n\n    if (windowBits < 0) { /* suppress zlib wrapper */\n      wrap = 0;\n      windowBits = -windowBits;\n    }\n\n    else if (windowBits > 15) {\n      wrap = 2;           /* write gzip wrapper instead */\n      windowBits -= 16;\n    }\n\n\n    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$1 ||\n      windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n      strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {\n      return err(strm, Z_STREAM_ERROR);\n    }\n\n\n    if (windowBits === 8) {\n      windowBits = 9;\n    }\n    /* until 256-byte window bug fixed */\n\n    const s = new DeflateState();\n\n    strm.state = s;\n    s.strm = strm;\n    s.status = INIT_STATE;     /* to pass state test in deflateReset() */\n\n    s.wrap = wrap;\n    s.gzhead = null;\n    s.w_bits = windowBits;\n    s.w_size = 1 << s.w_bits;\n    s.w_mask = s.w_size - 1;\n\n    s.hash_bits = memLevel + 7;\n    s.hash_size = 1 << s.hash_bits;\n    s.hash_mask = s.hash_size - 1;\n    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n    s.window = new Uint8Array(s.w_size * 2);\n    s.head = new Uint16Array(s.hash_size);\n    s.prev = new Uint16Array(s.w_size);\n\n    // Don't need mem init magic for JS.\n    //s.high_water = 0;  /* nothing written to s->window yet */\n\n    s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n    /* We overlay pending_buf and sym_buf. This works since the average size\n     * for length/distance pairs over any compressed block is assured to be 31\n     * bits or less.\n     *\n     * Analysis: The longest fixed codes are a length code of 8 bits plus 5\n     * extra bits, for lengths 131 to 257. The longest fixed distance codes are\n     * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest\n     * possible fixed-codes length/distance pair is then 31 bits total.\n     *\n     * sym_buf starts one-fourth of the way into pending_buf. So there are\n     * three bytes in sym_buf for every four bytes in pending_buf. Each symbol\n     * in sym_buf is three bytes -- two for the distance and one for the\n     * literal/length. As each symbol is consumed, the pointer to the next\n     * sym_buf value to read moves forward three bytes. From that symbol, up to\n     * 31 bits are written to pending_buf. The closest the written pending_buf\n     * bits gets to the next sym_buf symbol to read is just before the last\n     * code is written. At that time, 31*(n-2) bits have been written, just\n     * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at\n     * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1\n     * symbols are written.) The closest the writing gets to what is unread is\n     * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and\n     * can range from 128 to 32768.\n     *\n     * Therefore, at a minimum, there are 142 bits of space between what is\n     * written and what is read in the overlain buffers, so the symbols cannot\n     * be overwritten by the compressed data. That space is actually 139 bits,\n     * due to the three-bit fixed-code block header.\n     *\n     * That covers the case where either Z_FIXED is specified, forcing fixed\n     * codes, or when the use of fixed codes is chosen, because that choice\n     * results in a smaller compressed block than dynamic codes. That latter\n     * condition then assures that the above analysis also covers all dynamic\n     * blocks. A dynamic-code block will only be chosen to be emitted if it has\n     * fewer bits than a fixed-code block would for the same set of symbols.\n     * Therefore its average symbol length is assured to be less than 31. So\n     * the compressed data for a dynamic block also cannot overwrite the\n     * symbols from which it is being constructed.\n     */\n\n    s.pending_buf_size = s.lit_bufsize * 4;\n    s.pending_buf = new Uint8Array(s.pending_buf_size);\n\n    // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n    //s->sym_buf = s->pending_buf + s->lit_bufsize;\n    s.sym_buf = s.lit_bufsize;\n\n    //s->sym_end = (s->lit_bufsize - 1) * 3;\n    s.sym_end = (s.lit_bufsize - 1) * 3;\n    /* We avoid equality with lit_bufsize*3 because of wraparound at 64K\n     * on 16 bit machines and because stored blocks are restricted to\n     * 64K-1 bytes.\n     */\n\n    s.level = level;\n    s.strategy = strategy;\n    s.method = method;\n\n    return deflateReset(strm);\n  };\n\n  const deflateInit = (strm, level) => {\n\n    return deflateInit2(strm, level, Z_DEFLATED$1, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);\n  };\n\n\n  /* ========================================================================= */\n  const deflate$1 = (strm, flush) => {\n\n    if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {\n      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n    }\n\n    const s = strm.state;\n\n    if (!strm.output ||\n        (strm.avail_in !== 0 && !strm.input) ||\n        (s.status === FINISH_STATE && flush !== Z_FINISH$1)) {\n      return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n    }\n\n    const old_flush = s.last_flush;\n    s.last_flush = flush;\n\n    /* Flush as much pending output as possible */\n    if (s.pending !== 0) {\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        /* Since avail_out is 0, deflate will be called again with\n         * more output space, but possibly with both pending and\n         * avail_in equal to zero. There won't be anything to do,\n         * but this is not an error situation so make sure we\n         * return OK instead of BUF_ERROR at next call of deflate:\n         */\n        s.last_flush = -1;\n        return Z_OK$1;\n      }\n\n      /* Make sure there is something to do and avoid duplicate consecutive\n       * flushes. For repeated and useless calls with Z_FINISH, we keep\n       * returning Z_STREAM_END instead of Z_BUF_ERROR.\n       */\n    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n      flush !== Z_FINISH$1) {\n      return err(strm, Z_BUF_ERROR);\n    }\n\n    /* User must not provide more input after the first FINISH: */\n    if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n      return err(strm, Z_BUF_ERROR);\n    }\n\n    /* Write the header */\n    if (s.status === INIT_STATE && s.wrap === 0) {\n      s.status = BUSY_STATE;\n    }\n    if (s.status === INIT_STATE) {\n      /* zlib header */\n      let header = (Z_DEFLATED$1 + ((s.w_bits - 8) << 4)) << 8;\n      let level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n      s.status = BUSY_STATE;\n\n      /* Compression must start with an empty pending buffer */\n      flush_pending(strm);\n      if (s.pending !== 0) {\n        s.last_flush = -1;\n        return Z_OK$1;\n      }\n    }\n  //#ifdef GZIP\n    if (s.status === GZIP_STATE) {\n      /* gzip header */\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n\n        /* Compression must start with an empty pending buffer */\n        flush_pending(strm);\n        if (s.pending !== 0) {\n          s.last_flush = -1;\n          return Z_OK$1;\n        }\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    if (s.status === EXTRA_STATE) {\n      if (s.gzhead.extra/* != Z_NULL*/) {\n        let beg = s.pending;   /* start of bytes to update crc */\n        let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;\n        while (s.pending + left > s.pending_buf_size) {\n          let copy = s.pending_buf_size - s.pending;\n          // zmemcpy(s.pending_buf + s.pending,\n          //    s.gzhead.extra + s.gzindex, copy);\n          s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);\n          s.pending = s.pending_buf_size;\n          //--- HCRC_UPDATE(beg) ---//\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          //---//\n          s.gzindex += copy;\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK$1;\n          }\n          beg = 0;\n          left -= copy;\n        }\n        // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility\n        //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11\n        let gzhead_extra = new Uint8Array(s.gzhead.extra);\n        // zmemcpy(s->pending_buf + s->pending,\n        //     s->gzhead->extra + s->gzindex, left);\n        s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);\n        s.pending += left;\n        //--- HCRC_UPDATE(beg) ---//\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        //---//\n        s.gzindex = 0;\n      }\n      s.status = NAME_STATE;\n    }\n    if (s.status === NAME_STATE) {\n      if (s.gzhead.name/* != Z_NULL*/) {\n        let beg = s.pending;   /* start of bytes to update crc */\n        let val;\n        do {\n          if (s.pending === s.pending_buf_size) {\n            //--- HCRC_UPDATE(beg) ---//\n            if (s.gzhead.hcrc && s.pending > beg) {\n              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            //---//\n            flush_pending(strm);\n            if (s.pending !== 0) {\n              s.last_flush = -1;\n              return Z_OK$1;\n            }\n            beg = 0;\n          }\n          // JS specific: little magic to add zero terminator to end of string\n          if (s.gzindex < s.gzhead.name.length) {\n            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n          } else {\n            val = 0;\n          }\n          put_byte(s, val);\n        } while (val !== 0);\n        //--- HCRC_UPDATE(beg) ---//\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        //---//\n        s.gzindex = 0;\n      }\n      s.status = COMMENT_STATE;\n    }\n    if (s.status === COMMENT_STATE) {\n      if (s.gzhead.comment/* != Z_NULL*/) {\n        let beg = s.pending;   /* start of bytes to update crc */\n        let val;\n        do {\n          if (s.pending === s.pending_buf_size) {\n            //--- HCRC_UPDATE(beg) ---//\n            if (s.gzhead.hcrc && s.pending > beg) {\n              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            //---//\n            flush_pending(strm);\n            if (s.pending !== 0) {\n              s.last_flush = -1;\n              return Z_OK$1;\n            }\n            beg = 0;\n          }\n          // JS specific: little magic to add zero terminator to end of string\n          if (s.gzindex < s.gzhead.comment.length) {\n            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n          } else {\n            val = 0;\n          }\n          put_byte(s, val);\n        } while (val !== 0);\n        //--- HCRC_UPDATE(beg) ---//\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        //---//\n      }\n      s.status = HCRC_STATE;\n    }\n    if (s.status === HCRC_STATE) {\n      if (s.gzhead.hcrc) {\n        if (s.pending + 2 > s.pending_buf_size) {\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK$1;\n          }\n        }\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n      }\n      s.status = BUSY_STATE;\n\n      /* Compression must start with an empty pending buffer */\n      flush_pending(strm);\n      if (s.pending !== 0) {\n        s.last_flush = -1;\n        return Z_OK$1;\n      }\n    }\n  //#endif\n\n    /* Start a new block or continue the current one.\n     */\n    if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n      (flush !== Z_NO_FLUSH$1 && s.status !== FINISH_STATE)) {\n      let bstate = s.level === 0 ? deflate_stored(s, flush) :\n                   s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :\n                   s.strategy === Z_RLE ? deflate_rle(s, flush) :\n                   configuration_table[s.level].func(s, flush);\n\n      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n        s.status = FINISH_STATE;\n      }\n      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n        if (strm.avail_out === 0) {\n          s.last_flush = -1;\n          /* avoid BUF_ERROR next call, see above */\n        }\n        return Z_OK$1;\n        /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n         * of deflate should use the same flush parameter to make sure\n         * that the flush is complete. So we don't have to output an\n         * empty block here, this will be done at next call. This also\n         * ensures that for a very small output buffer, we emit at most\n         * one empty block.\n         */\n      }\n      if (bstate === BS_BLOCK_DONE) {\n        if (flush === Z_PARTIAL_FLUSH) {\n          _tr_align(s);\n        }\n        else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n          _tr_stored_block(s, 0, 0, false);\n          /* For a full flush, this empty block will be recognized\n           * as a special marker by inflate_sync().\n           */\n          if (flush === Z_FULL_FLUSH$1) {\n            /*** CLEAR_HASH(s); ***/             /* forget history */\n            zero(s.head); // Fill with NIL (= 0);\n\n            if (s.lookahead === 0) {\n              s.strstart = 0;\n              s.block_start = 0;\n              s.insert = 0;\n            }\n          }\n        }\n        flush_pending(strm);\n        if (strm.avail_out === 0) {\n          s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n          return Z_OK$1;\n        }\n      }\n    }\n\n    if (flush !== Z_FINISH$1) { return Z_OK$1; }\n    if (s.wrap <= 0) { return Z_STREAM_END$1; }\n\n    /* Write the trailer */\n    if (s.wrap === 2) {\n      put_byte(s, strm.adler & 0xff);\n      put_byte(s, (strm.adler >> 8) & 0xff);\n      put_byte(s, (strm.adler >> 16) & 0xff);\n      put_byte(s, (strm.adler >> 24) & 0xff);\n      put_byte(s, strm.total_in & 0xff);\n      put_byte(s, (strm.total_in >> 8) & 0xff);\n      put_byte(s, (strm.total_in >> 16) & 0xff);\n      put_byte(s, (strm.total_in >> 24) & 0xff);\n    }\n    else\n    {\n      putShortMSB(s, strm.adler >>> 16);\n      putShortMSB(s, strm.adler & 0xffff);\n    }\n\n    flush_pending(strm);\n    /* If avail_out is zero, the application will call deflate again\n     * to flush the rest.\n     */\n    if (s.wrap > 0) { s.wrap = -s.wrap; }\n    /* write the trailer only once! */\n    return s.pending !== 0 ? Z_OK$1 : Z_STREAM_END$1;\n  };\n\n\n  const deflateEnd = (strm) => {\n\n    if (deflateStateCheck(strm)) {\n      return Z_STREAM_ERROR;\n    }\n\n    const status = strm.state.status;\n\n    strm.state = null;\n\n    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK$1;\n  };\n\n\n  /* =========================================================================\n   * Initializes the compression dictionary from the given byte\n   * sequence without producing any compressed output.\n   */\n  const deflateSetDictionary = (strm, dictionary) => {\n\n    let dictLength = dictionary.length;\n\n    if (deflateStateCheck(strm)) {\n      return Z_STREAM_ERROR;\n    }\n\n    const s = strm.state;\n    const wrap = s.wrap;\n\n    if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n      return Z_STREAM_ERROR;\n    }\n\n    /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n    if (wrap === 1) {\n      /* adler32(strm->adler, dictionary, dictLength); */\n      strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n    }\n\n    s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n    /* if dictionary would fill window, just replace the history */\n    if (dictLength >= s.w_size) {\n      if (wrap === 0) {            /* already empty otherwise */\n        /*** CLEAR_HASH(s); ***/\n        zero(s.head); // Fill with NIL (= 0);\n        s.strstart = 0;\n        s.block_start = 0;\n        s.insert = 0;\n      }\n      /* use the tail */\n      // dictionary = dictionary.slice(dictLength - s.w_size);\n      let tmpDict = new Uint8Array(s.w_size);\n      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n      dictionary = tmpDict;\n      dictLength = s.w_size;\n    }\n    /* insert dictionary into window and hash */\n    const avail = strm.avail_in;\n    const next = strm.next_in;\n    const input = strm.input;\n    strm.avail_in = dictLength;\n    strm.next_in = 0;\n    strm.input = dictionary;\n    fill_window(s);\n    while (s.lookahead >= MIN_MATCH) {\n      let str = s.strstart;\n      let n = s.lookahead - (MIN_MATCH - 1);\n      do {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n        s.head[s.ins_h] = str;\n        str++;\n      } while (--n);\n      s.strstart = str;\n      s.lookahead = MIN_MATCH - 1;\n      fill_window(s);\n    }\n    s.strstart += s.lookahead;\n    s.block_start = s.strstart;\n    s.insert = s.lookahead;\n    s.lookahead = 0;\n    s.match_length = s.prev_length = MIN_MATCH - 1;\n    s.match_available = 0;\n    strm.next_in = next;\n    strm.input = input;\n    strm.avail_in = avail;\n    s.wrap = wrap;\n    return Z_OK$1;\n  };\n\n\n  var deflateInit_1 = deflateInit;\n  var deflateInit2_1 = deflateInit2;\n  var deflateReset_1 = deflateReset;\n  var deflateResetKeep_1 = deflateResetKeep;\n  var deflateSetHeader_1 = deflateSetHeader;\n  var deflate_2$1 = deflate$1;\n  var deflateEnd_1 = deflateEnd;\n  var deflateSetDictionary_1 = deflateSetDictionary;\n  var deflateInfo = 'pako deflate (from Nodeca project)';\n\n  /* Not implemented\n  module.exports.deflateBound = deflateBound;\n  module.exports.deflateCopy = deflateCopy;\n  module.exports.deflateGetDictionary = deflateGetDictionary;\n  module.exports.deflateParams = deflateParams;\n  module.exports.deflatePending = deflatePending;\n  module.exports.deflatePrime = deflatePrime;\n  module.exports.deflateTune = deflateTune;\n  */\n\n  var deflate_1$1 = {\n  \tdeflateInit: deflateInit_1,\n  \tdeflateInit2: deflateInit2_1,\n  \tdeflateReset: deflateReset_1,\n  \tdeflateResetKeep: deflateResetKeep_1,\n  \tdeflateSetHeader: deflateSetHeader_1,\n  \tdeflate: deflate_2$1,\n  \tdeflateEnd: deflateEnd_1,\n  \tdeflateSetDictionary: deflateSetDictionary_1,\n  \tdeflateInfo: deflateInfo\n  };\n\n  const _has = (obj, key) => {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  };\n\n  var assign = function (obj /*from1, from2, from3, ...*/) {\n    const sources = Array.prototype.slice.call(arguments, 1);\n    while (sources.length) {\n      const source = sources.shift();\n      if (!source) { continue; }\n\n      if (typeof source !== 'object') {\n        throw new TypeError(source + 'must be non-object');\n      }\n\n      for (const p in source) {\n        if (_has(source, p)) {\n          obj[p] = source[p];\n        }\n      }\n    }\n\n    return obj;\n  };\n\n\n  // Join array of chunks to single array.\n  var flattenChunks = (chunks) => {\n    // calculate data length\n    let len = 0;\n\n    for (let i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    const result = new Uint8Array(len);\n\n    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {\n      let chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  };\n\n  var common = {\n  \tassign: assign,\n  \tflattenChunks: flattenChunks\n  };\n\n  // String encode/decode helpers\n\n\n  // Quick check if we can use fast array to bin string conversion\n  //\n  // - apply(Array) can fail on Android 2.2\n  // - apply(Uint8Array) can fail on iOS 5.1 Safari\n  //\n  let STR_APPLY_UIA_OK = true;\n\n  try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n  // Table with utf8 lengths (calculated by first byte of sequence)\n  // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n  // because max possible codepoint is 0x10ffff\n  const _utf8len = new Uint8Array(256);\n  for (let q = 0; q < 256; q++) {\n    _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n  }\n  _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n  // convert string to array (typed, when possible)\n  var string2buf = (str) => {\n    if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n      return new TextEncoder().encode(str);\n    }\n\n    let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n      c = str.charCodeAt(m_pos);\n      if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n        c2 = str.charCodeAt(m_pos + 1);\n        if ((c2 & 0xfc00) === 0xdc00) {\n          c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n          m_pos++;\n        }\n      }\n      buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    buf = new Uint8Array(buf_len);\n\n    // convert\n    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n      c = str.charCodeAt(m_pos);\n      if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n        c2 = str.charCodeAt(m_pos + 1);\n        if ((c2 & 0xfc00) === 0xdc00) {\n          c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n          m_pos++;\n        }\n      }\n      if (c < 0x80) {\n        /* one byte */\n        buf[i++] = c;\n      } else if (c < 0x800) {\n        /* two bytes */\n        buf[i++] = 0xC0 | (c >>> 6);\n        buf[i++] = 0x80 | (c & 0x3f);\n      } else if (c < 0x10000) {\n        /* three bytes */\n        buf[i++] = 0xE0 | (c >>> 12);\n        buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n        buf[i++] = 0x80 | (c & 0x3f);\n      } else {\n        /* four bytes */\n        buf[i++] = 0xf0 | (c >>> 18);\n        buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n        buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n        buf[i++] = 0x80 | (c & 0x3f);\n      }\n    }\n\n    return buf;\n  };\n\n  // Helper\n  const buf2binstring = (buf, len) => {\n    // On Chrome, the arguments in a function call that are allowed is `65534`.\n    // If the length of the buffer is smaller than that, we can use this optimization,\n    // otherwise we will take a slower path.\n    if (len < 65534) {\n      if (buf.subarray && STR_APPLY_UIA_OK) {\n        return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n      }\n    }\n\n    let result = '';\n    for (let i = 0; i < len; i++) {\n      result += String.fromCharCode(buf[i]);\n    }\n    return result;\n  };\n\n\n  // convert array to string\n  var buf2string = (buf, max) => {\n    const len = max || buf.length;\n\n    if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {\n      return new TextDecoder().decode(buf.subarray(0, max));\n    }\n\n    let i, out;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    const utf16buf = new Array(len * 2);\n\n    for (out = 0, i = 0; i < len;) {\n      let c = buf[i++];\n      // quick process ascii\n      if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n      let c_len = _utf8len[c];\n      // skip 5 & 6 byte codes\n      if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n      // apply mask on first byte\n      c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n      // join the rest\n      while (c_len > 1 && i < len) {\n        c = (c << 6) | (buf[i++] & 0x3f);\n        c_len--;\n      }\n\n      // terminated by end of string?\n      if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n      if (c < 0x10000) {\n        utf16buf[out++] = c;\n      } else {\n        c -= 0x10000;\n        utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n        utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n      }\n    }\n\n    return buf2binstring(utf16buf, out);\n  };\n\n\n  // Calculate max possible position in utf8 buffer,\n  // that will not break sequence. If that's not possible\n  // - (very small limits) return max size as is.\n  //\n  // buf[] - utf8 bytes array\n  // max   - length limit (mandatory);\n  var utf8border = (buf, max) => {\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    let pos = max - 1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means buffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n  };\n\n  var strings = {\n  \tstring2buf: string2buf,\n  \tbuf2string: buf2string,\n  \tutf8border: utf8border\n  };\n\n  // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n  //\n  // This software is provided 'as-is', without any express or implied\n  // warranty. In no event will the authors be held liable for any damages\n  // arising from the use of this software.\n  //\n  // Permission is granted to anyone to use this software for any purpose,\n  // including commercial applications, and to alter it and redistribute it\n  // freely, subject to the following restrictions:\n  //\n  // 1. The origin of this software must not be misrepresented; you must not\n  //   claim that you wrote the original software. If you use this software\n  //   in a product, an acknowledgment in the product documentation would be\n  //   appreciated but is not required.\n  // 2. Altered source versions must be plainly marked as such, and must not be\n  //   misrepresented as being the original software.\n  // 3. This notice may not be removed or altered from any source distribution.\n\n  function ZStream() {\n    /* next input byte */\n    this.input = null; // JS specific, because we have no pointers\n    this.next_in = 0;\n    /* number of bytes available at input */\n    this.avail_in = 0;\n    /* total number of input bytes read so far */\n    this.total_in = 0;\n    /* next output byte should be put there */\n    this.output = null; // JS specific, because we have no pointers\n    this.next_out = 0;\n    /* remaining free space at output */\n    this.avail_out = 0;\n    /* total number of bytes output so far */\n    this.total_out = 0;\n    /* last error message, NULL if no error */\n    this.msg = ''/*Z_NULL*/;\n    /* not visible by applications */\n    this.state = null;\n    /* best guess about the data type: binary or text */\n    this.data_type = 2/*Z_UNKNOWN*/;\n    /* adler32 value of the uncompressed data */\n    this.adler = 0;\n  }\n\n  var zstream = ZStream;\n\n  const toString = Object.prototype.toString;\n\n  /* Public constants ==========================================================*/\n  /* ===========================================================================*/\n\n  const {\n    Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH,\n    Z_OK, Z_STREAM_END,\n    Z_DEFAULT_COMPRESSION,\n    Z_DEFAULT_STRATEGY,\n    Z_DEFLATED\n  } = constants$1;\n\n  /* ===========================================================================*/\n\n\n  /**\n   * class Deflate\n   *\n   * Generic JS-style wrapper for zlib calls. If you don't need\n   * streaming behaviour - use more simple functions: [[deflate]],\n   * [[deflateRaw]] and [[gzip]].\n   **/\n\n  /* internal\n   * Deflate.chunks -> Array\n   *\n   * Chunks of output data, if [[Deflate#onData]] not overridden.\n   **/\n\n  /**\n   * Deflate.result -> Uint8Array\n   *\n   * Compressed result, generated by default [[Deflate#onData]]\n   * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n   * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n   **/\n\n  /**\n   * Deflate.err -> Number\n   *\n   * Error code after deflate finished. 0 (Z_OK) on success.\n   * You will not need it in real life, because deflate errors\n   * are possible only on wrong options or bad `onData` / `onEnd`\n   * custom handlers.\n   **/\n\n  /**\n   * Deflate.msg -> String\n   *\n   * Error message, if [[Deflate.err]] != 0\n   **/\n\n\n  /**\n   * new Deflate(options)\n   * - options (Object): zlib deflate options.\n   *\n   * Creates new deflator instance with specified params. Throws exception\n   * on bad params. Supported options:\n   *\n   * - `level`\n   * - `windowBits`\n   * - `memLevel`\n   * - `strategy`\n   * - `dictionary`\n   *\n   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n   * for more information on these.\n   *\n   * Additional options, for internal needs:\n   *\n   * - `chunkSize` - size of generated data chunks (16K by default)\n   * - `raw` (Boolean) - do raw deflate\n   * - `gzip` (Boolean) - create gzip wrapper\n   * - `header` (Object) - custom header for gzip\n   *   - `text` (Boolean) - true if compressed data believed to be text\n   *   - `time` (Number) - modification time, unix timestamp\n   *   - `os` (Number) - operation system code\n   *   - `extra` (Array) - array of bytes with extra data (max 65536)\n   *   - `name` (String) - file name (binary string)\n   *   - `comment` (String) - comment (binary string)\n   *   - `hcrc` (Boolean) - true if header crc should be added\n   *\n   * ##### Example:\n   *\n   * ```javascript\n   * const pako = require('pako')\n   *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n   *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n   *\n   * const deflate = new pako.Deflate({ level: 3});\n   *\n   * deflate.push(chunk1, false);\n   * deflate.push(chunk2, true);  // true -> last chunk\n   *\n   * if (deflate.err) { throw new Error(deflate.err); }\n   *\n   * console.log(deflate.result);\n   * ```\n   **/\n  function Deflate(options) {\n    this.options = common.assign({\n      level: Z_DEFAULT_COMPRESSION,\n      method: Z_DEFLATED,\n      chunkSize: 16384,\n      windowBits: 15,\n      memLevel: 8,\n      strategy: Z_DEFAULT_STRATEGY\n    }, options || {});\n\n    let opt = this.options;\n\n    if (opt.raw && (opt.windowBits > 0)) {\n      opt.windowBits = -opt.windowBits;\n    }\n\n    else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n      opt.windowBits += 16;\n    }\n\n    this.err    = 0;      // error code, if happens (0 = Z_OK)\n    this.msg    = '';     // error message\n    this.ended  = false;  // used to avoid multiple onEnd() calls\n    this.chunks = [];     // chunks of compressed data\n\n    this.strm = new zstream();\n    this.strm.avail_out = 0;\n\n    let status = deflate_1$1.deflateInit2(\n      this.strm,\n      opt.level,\n      opt.method,\n      opt.windowBits,\n      opt.memLevel,\n      opt.strategy\n    );\n\n    if (status !== Z_OK) {\n      throw new Error(messages[status]);\n    }\n\n    if (opt.header) {\n      deflate_1$1.deflateSetHeader(this.strm, opt.header);\n    }\n\n    if (opt.dictionary) {\n      let dict;\n      // Convert data if needed\n      if (typeof opt.dictionary === 'string') {\n        // If we need to compress text, change encoding to utf8.\n        dict = strings.string2buf(opt.dictionary);\n      } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n        dict = new Uint8Array(opt.dictionary);\n      } else {\n        dict = opt.dictionary;\n      }\n\n      status = deflate_1$1.deflateSetDictionary(this.strm, dict);\n\n      if (status !== Z_OK) {\n        throw new Error(messages[status]);\n      }\n\n      this._dict_set = true;\n    }\n  }\n\n  /**\n   * Deflate#push(data[, flush_mode]) -> Boolean\n   * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n   *   converted to utf8 byte sequence.\n   * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n   *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n   *\n   * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n   * new compressed chunks. Returns `true` on success. The last data block must\n   * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n   * buffers and call [[Deflate#onEnd]].\n   *\n   * On fail call [[Deflate#onEnd]] with error code and return false.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * push(chunk, false); // push one of data chunks\n   * ...\n   * push(chunk, true);  // push last chunk\n   * ```\n   **/\n  Deflate.prototype.push = function (data, flush_mode) {\n    const strm = this.strm;\n    const chunkSize = this.options.chunkSize;\n    let status, _flush_mode;\n\n    if (this.ended) { return false; }\n\n    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n    else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n\n    // Convert data if needed\n    if (typeof data === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      strm.input = strings.string2buf(data);\n    } else if (toString.call(data) === '[object ArrayBuffer]') {\n      strm.input = new Uint8Array(data);\n    } else {\n      strm.input = data;\n    }\n\n    strm.next_in = 0;\n    strm.avail_in = strm.input.length;\n\n    for (;;) {\n      if (strm.avail_out === 0) {\n        strm.output = new Uint8Array(chunkSize);\n        strm.next_out = 0;\n        strm.avail_out = chunkSize;\n      }\n\n      // Make sure avail_out > 6 to avoid repeating markers\n      if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {\n        this.onData(strm.output.subarray(0, strm.next_out));\n        strm.avail_out = 0;\n        continue;\n      }\n\n      status = deflate_1$1.deflate(strm, _flush_mode);\n\n      // Ended => flush and finish\n      if (status === Z_STREAM_END) {\n        if (strm.next_out > 0) {\n          this.onData(strm.output.subarray(0, strm.next_out));\n        }\n        status = deflate_1$1.deflateEnd(this.strm);\n        this.onEnd(status);\n        this.ended = true;\n        return status === Z_OK;\n      }\n\n      // Flush if out buffer full\n      if (strm.avail_out === 0) {\n        this.onData(strm.output);\n        continue;\n      }\n\n      // Flush if requested and has data\n      if (_flush_mode > 0 && strm.next_out > 0) {\n        this.onData(strm.output.subarray(0, strm.next_out));\n        strm.avail_out = 0;\n        continue;\n      }\n\n      if (strm.avail_in === 0) break;\n    }\n\n    return true;\n  };\n\n\n  /**\n   * Deflate#onData(chunk) -> Void\n   * - chunk (Uint8Array): output data.\n   *\n   * By default, stores data blocks in `chunks[]` property and glue\n   * those in `onEnd`. Override this handler, if you need another behaviour.\n   **/\n  Deflate.prototype.onData = function (chunk) {\n    this.chunks.push(chunk);\n  };\n\n\n  /**\n   * Deflate#onEnd(status) -> Void\n   * - status (Number): deflate status. 0 (Z_OK) on success,\n   *   other if not.\n   *\n   * Called once after you tell deflate that the input stream is\n   * complete (Z_FINISH). By default - join collected chunks,\n   * free memory and fill `results` / `err` properties.\n   **/\n  Deflate.prototype.onEnd = function (status) {\n    // On success - join\n    if (status === Z_OK) {\n      this.result = common.flattenChunks(this.chunks);\n    }\n    this.chunks = [];\n    this.err = status;\n    this.msg = this.strm.msg;\n  };\n\n\n  /**\n   * deflate(data[, options]) -> Uint8Array\n   * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n   * - options (Object): zlib deflate options.\n   *\n   * Compress `data` with deflate algorithm and `options`.\n   *\n   * Supported options are:\n   *\n   * - level\n   * - windowBits\n   * - memLevel\n   * - strategy\n   * - dictionary\n   *\n   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n   * for more information on these.\n   *\n   * Sugar (options):\n   *\n   * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n   *   negative windowBits implicitly.\n   *\n   * ##### Example:\n   *\n   * ```javascript\n   * const pako = require('pako')\n   * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n   *\n   * console.log(pako.deflate(data));\n   * ```\n   **/\n  function deflate(input, options) {\n    const deflator = new Deflate(options);\n\n    deflator.push(input, true);\n\n    // That will never happens, if you don't cheat with options :)\n    if (deflator.err) { throw deflator.msg || messages[deflator.err]; }\n\n    return deflator.result;\n  }\n\n\n  /**\n   * deflateRaw(data[, options]) -> Uint8Array\n   * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n   * - options (Object): zlib deflate options.\n   *\n   * The same as [[deflate]], but creates raw data, without wrapper\n   * (header and adler32 crc).\n   **/\n  function deflateRaw(input, options) {\n    options = options || {};\n    options.raw = true;\n    return deflate(input, options);\n  }\n\n\n  /**\n   * gzip(data[, options]) -> Uint8Array\n   * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n   * - options (Object): zlib deflate options.\n   *\n   * The same as [[deflate]], but create gzip wrapper instead of\n   * deflate one.\n   **/\n  function gzip(input, options) {\n    options = options || {};\n    options.gzip = true;\n    return deflate(input, options);\n  }\n\n\n  var Deflate_1 = Deflate;\n  var deflate_2 = deflate;\n  var deflateRaw_1 = deflateRaw;\n  var gzip_1 = gzip;\n  var constants = constants$1;\n\n  var deflate_1 = {\n  \tDeflate: Deflate_1,\n  \tdeflate: deflate_2,\n  \tdeflateRaw: deflateRaw_1,\n  \tgzip: gzip_1,\n  \tconstants: constants\n  };\n\n  exports.Deflate = Deflate_1;\n  exports.constants = constants;\n  exports[\"default\"] = deflate_1;\n  exports.deflate = deflate_2;\n  exports.deflateRaw = deflateRaw_1;\n  exports.gzip = gzip_1;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"],"mappings":"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","ignoreList":[]}